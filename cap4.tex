En este capítulo hablaré sobre los diferentes niveles de optimización que se pueden seleccionar durante la compilación y sus consecuencias en el programa final. Para ver dichas consecuencias se propondrá un programa que se ejecute en la placa microcontroladora y con el que se podrán medir los efectos de las optimizaciones. Por último se creará un programa que muestra las limitaciones de la biblioteca Arduino y que, además, está relacionado con las telecomunicaciones.
\section{Niveles de optimización}
Durante la compilación es posible especificar, mediante la opción \comando{-O} diferentes niveles de optimización. Estos niveles agrupan una serie de optimizaciones.

\begin{table}[H]
\begin{center}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    Nivel de optimización & Descripción\\
    \hline
    \hline
   	\comando{-O0} & Opción por defecto. Reduce el tiempo de compilación y facilita la depuración.\\
    \hline
    \comando{-O1} & Optimiza, pero aumenta el tiempo de compilación y la memoria empleada.\\
    \hline
    \comando{-O2} & Optimiza más todavía. \programa{GCC} realiza casi todas la optimizaciones que no impliquen aumento de la velocidad a costa de un mayor tamaño del programa.\\
    \hline
    \comando{-O3} & Optimiza todavía más que \comando{-O2}, incluyendo las optimizaciones que aumenten el tamaño del ejecutable.\\
    \hline
    \comando{-Os} & Optimiza el tamaño del programa. Habilita todas las optimizaciones de \comando{-O2} que normalmente no aumenten el tamaño del código y realiza más optimizaciones destinadas a reducir el tamaño del programa.\\
    \hline
  \end{tabularx}
\end{center}
\caption{Niveles de optimización}
\label{tab:optimizacionx}
\end{table}

Cada uno de estos niveles (a excepción de \comando{-Os}) añade una serie de optimizaciones sobre el nivel inicial \comando{-O0}.

Para poder averiguar que optimizaciones lleva acabo el compilador dependiendo del nivel podemos emplear el comando \comando{pic32-gcc -Ox -Q --help=optimizers | grep enabled} sustituyendo \comando{x} por el nivel que queramos. Esta orden muestra todos las posibles optimizaciones, indicando si están habilitadas o no y para ver solo las habilitadas pasamos el resultado a \comando{grep} para filtrarlas.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-loops & -fargument-alias\\
		-fbranch-count-reg & -fcommon\\
		-fdata-sections & -fdce\\
		-fdelete-null-pointer-checks & -fdse\\
		-fearly-inlining & -fgcse-lm\\
		-finline-functions-called-once & -fivopts\\
		-fjump-tables & -fmath-errno\\
		-fmove-loop-invariants & -fpeephole\\
		-frename-registers & -fsched-critical-path-heuristic\\
		-fsched-dep-count-heuristic & -fsched-group-heurisitc\\
		-fsched-interblock & -fsched-last-insn-heuristic\\
		-fsched-spec & -fsched-spec-insn-heuristic\\
		-fsched-stalled-insns-dep & -fsigned-zeros\\
		-fsplit-ivs-in-unroller & -ftoplevel-reorder\\
		-ftrapping-math & -ftree-cselim\\
		-ftree-forwprop & -ftree-loop-im\\
		-ftree-loop-ivcanon & -ftree-loop-optimize\\
		-ftree-phiprop & -ftree-pta\\
		-ftree-reassoc & -ftree-scev-cprop\\
		-ftree-slp-vectorize & -ftree-vect-loop-version\\
		-funit-at-a-time & -fvar-tracking\\
		-fvar-tracking-assignments & -fweb\\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones del nivel 0.}
\label{opt0}
\end{table}

En el nivel más bajo, \programa{gcc} ya realiza optimizaciones. Todas las optimizaciones que comienzan con \comando{-ftree} afectan al árbol sintáctico que utiliza \programa{gcc} como representación interna del programa. También se puede observar como una de las optimizaciones que incluye este nivel es \comando{-fdata-sections} y a pesar de esto \programa{MPIDE} la incluye explícitamente cuando ejecuta la compilación. Otro grupo de optimizaciones que ya aparecen en este nivel son las que comienzan \comando{-fsched} que afectan a la reordenación de instrucciones (en ensamblador) para aprovechar lo mejor posible la segmentación de instrucciones del procesador evitando ciclos de espera. En este nivel, si el programa tiene una función que solo es llamada una vez, su llamada será sustituida por el contenido de la función, directamente, gracias a la opción \comando{-finline-functions-called-once}.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-fcprop-registers & -fdefer-pop\\
		-fdelayed-branch & -fforward-propagate\\
		-fguess-branch-probability &-fif-conversion\\
		-fif-conversion2 & -fipa-pure-const\\
		-fipa-reference & -fmerge-constants\\
		-fomit-frame-pointer & -fsplit-wide-types\\
		-ftree-ccp & -ftree-ch\\
		-ftree-copy-prop & -ftree-copyrename\\
		-ftree-dce & -ftree-dominator-opts\\
		-ftree-dse & -ftree-fre\\
		-ftree-sink & -ftree-sra\\
		-ftree-ter & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O1' al nivel `O0'.}
\label{optimizaciones1}
\end{table}

En el nivel 1 se añaden más optimizaciones que afectan al arbol sintáctico, suponiendo estas casi la mitad de las nuevas optimizaciones. \comando{-fif-conversion} y \comando{-fif-conversion2} tienen como obejtivo tratar de transformar secciones de código donde se usan saltos condicionales para que no los requieran, reduciendo de esta forma el número de instrucciones. También encontramos aquí \comando{-fdelayed-branch} que intentará reordenar las instrucciones para aprovechar el tiempo que se pierde durante saltos condicionales. Si se produce una instrucción de salto condicional, no es posible saber cual es la instrucción que se debe ejecutar después hasta que acabe, por lo que normalmente la siguiente instrucción suele ser un \comando{nop}. Si el procesador lo soporta, se mueve una de las instrucciones anteriores a la instrucción de salto que no tenga ninguna dependencia con esta, para aprovechar el hueco libre. En lugar de colocar después del salto, una instrucción anterior, \programa{gcc} también trata de predecir, con la opción \comando{-fguess-branch-probability}, que se ejecutará despues por lo que este lugar lo ocupará la primera instrucción de uno de los destinos. Si la predicción resulta erronea, se descartará esta instrucción.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-functions & -falign-jumps\\
		-falign-labels & -fcaller-saves\\
		-fcrossjumping & -fcse-follow-jumps\\
		-fexpensive-optimizations & -fgcse\\
		-finline-small-functions & -fipa-cp\\
		-fipa-sra & -foptimize-register-move\\
		-foptimize-sibling-calls & -fpeephole2\\
		-fregmove & -fremove-local-statics\\
		-freorder-blocks & -freorder-functions\\
		-frerun-cse-after-loop & -fschedule-insns\\
		-fschedule-insns2 & -fstrict-aliasing\\
		-fthread-jumps & -ftree-builtin-call-dce\\
		-ftree-pre & -ftree-switch-conversion\\
		-ftree-vrp & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O2' al nivel `O1'.}
\label{optimizaciones2}
\end{table}

El nivel 2 incluye muchas más optimizaciones. En este nivel encontramos las optimizaciones \comando{-falign} que se encargan de alinear el comienzo de funciones, saltos y etiquetas (\comando{-falign-functions}, \comando{-falign-jumps} y \comando{-falign-labels}) en memoria. Su alineamiento en memoria supone una carga más rápida en detrimento del tamaño de la aplicación final, ya que se necesita añadir \comando{nop}s para que las funciones comiencen en bloques de N bytes, donde N depende del procesador.Con la opción \comando{-finline-small-functions} el contenido de las funciones pequeñas se copia en el lugar del código donde son llamadas. El requisito que deben cumplir estas funciones es que el espacio que ocupen al copiarse sea inferior al que sería ocupado si fuesen llamadas. De este modo, si usamos este nivel de optimización podemos escribir funciones triviales que nos ayuden a que el programa sea mas legible sin perder rendimiento ni espacio.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-fgcse-after-reload & -finline-functions\\
		-fipa-cp-clone & -fpredictive-commoning\\
		-ftree-pre-partial-partial & -ftree-vectorize\\
		-funswitch-loops & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O3' al nivel `O2'.}
\label{optimizaciones3}
\end{table}

En el nivel más alto \programa{gcc} considera todas las funciones para que su contenido sustituya a las llamadas a las mismas, gracias a la opción \comando{-finline-functions}. Es decir, ya no se sustituyen solo las funciones cuyo contenido sea menor que la sobrecarga que supone la llamada a la función. La consecuencia directa de está optimización es un aumento considerable del programa final y aumento del rendimiento al eliminar el código de llamada y retorno de una función. 

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-functions & -falign-jumps\\
		-falign-loops & -falign-labels\\
		-freorder-blocks & -freorder-blocks-and-partition\\
		-fprefetch-loop-arrays & -ftree-vect-loop-version\\
		\hline
\end{tabular}
\end{center}
\caption{Optimizaciones del nivel `O2' que no se realizan en el nivel `Os'.}
\label{optimizaciones_s}
\end{table}

Las optimizaciones que lleva acabo el compilador cuando se activa la opción \comando{-Os} (Optimizar para el tamaño) son las mismas que cuando se usa \comando{-O2} a excepción de las que se encuentran en la tabla \ref{optimizaciones_s}. Estas optimizaciones son las que, aumentando el rendimiento, mas aumentan el tamaño de la aplicación final.

Cada nivel ofrece diferentes optimizaciones, aumentando el rendimiento con forme se aumenta el nivel. Es necesario valorar que nivel es el más adecuado para la aplicación. Por ejemplo, en un entorno empotrado (embedded) como sería el de un microcontrolador, debemos tener en cuenta la cantidad de memoria que tiene disponible al elegir la optimización del programa. Es posible elegir un nivel alto de optimización si el programa es pequeño y, por lo tanto, la memoria es suficiente. Si por el contrario la memoria es escasa se tendrá que elegir una optimización que no aumente el tamaño del programa. En el caso de depuración del código, el nivel más adecuado suele ser el más bajo ya que en este nivel, el compilador no modifica la estructura del programa, ni reordena instrucciones, haciendo más fácil la lectura del mismo en ensamblador.

Por último, es importante mencionar que se puede elegir un nivel de los cuatro disponibles y añadir más optimizaciones o quitarlas en la línea de comandos. Por ejemplo, sería posible elegir el nivel 3 de optimización, sin usar \comando{-finline-functions} añadiendo como argumento \comando{-fno-inline-functions}. Todas las opciones mencionadas antes se pueden negar añadiendo `no' a la opción. También podemos añadir optimizaciones que no se encuentran en ninguno de estos niveles, como \comando{-funroll-loops}\footnote{Esta opción `desenrolla' bucles, repitiendo el bloque de ejecución y reduciendo las veces que se ejecuta.} en la línea de comandos.

\section{Aplicación para ChipKIT}

Para ver los efectos de las optimizaciones que \programa{gcc} pueda efectuar, he creado una aplicación para ChipKIT. Se trata de un terminal al que podemos acceder de forma remota. Conectándonos a la placa a través de la red de área local tendremos acceso a un terminal básico en el que se pueden ejecutar varios comandos. La conexión se realiza utilizando el protocolo TCP en el puerto 23. He elegido este puerto al ser el estándar de Telnet aunque hubiese sido posible elegir cualquier otro. Para conectarse a la placa solo es necesario un programa que pueda establecer esta conexión, por lo que se puede usar el propio \programa{telnet} o \programa{netcat}. Con este último trabajamos directamente en la capa de transporte del modelo OSI, obviando todas las convenciones, procedimientos y comandos de la capa de aplicación.

Una vez establecida la conexión con la aplicación hay disponibles varios comandos que se pueden ejecutar. Se trata de comandos de ordenación en su mayoría, que permiten ordenar un array de números que se pasa como argumento del comando. Los elementos del array pueden estar separados por espacios, tabulaciones o comas. Dependiendo del nombre del comando, el array se ordena con un algoritmo determinado.
\begin{description}
	\item[\comando{bubble0}, \comando{bubble1}, \comando{bubble2}, \comando{bubble3}] Ordenan los números usando el algoritmo `Bubble Sort'.
	\item[\comando{quick0}, \comando{quick1}, \comando{quick2}, \comando{quick3}] Ordenan los números usando el algoritmo `Quick Sort'.
	\item[\comando{sel0}, \comando{sel1}, \comando{sel2}, \comando{sel3}] Ordenan los números usando el algoritmo `Selection Sort'.
	\item[\comando{comparar}] Reordena un array de números aleatorios usando todos los algoritmos anteriores.
	\item[\comando{help}] Muestra los comandos disponibles.
	\item[\comando{exit}] Cierra la conexión.
\end{description}

Por ejemplo, si quisieramos ordenar el vector [9 8 7 6 5 4 3 2 1] usando el algoritmo `Bubble Sort' escribiríamos lo siguiente:\footnote{Este vector representa el peor caso para este algoritmo (para esta longitud de vector), al estar los números ordenados de mayor a menor.}
\begin{lstlisting}
bubble0 9 8 7 6 5 4 3 2 1
\end{lstlisting}

El número que acompaña a cada uno de los comandos indica el nivel de optimización con el que han sido compilados, de este modo es posible probar el efecto de los distintos niveles sin tener que recompilar y volver a cargar el programa. En el programa se han implementado dos modos para conocer el tiempo que tardan en completarse los comandos. El primero de ellos implica llamar a las funciones \comando{millis()} y \comando{micros()} antes de que se ejecute el comando y al finalizar este. Estos dos comandos devuelven la cuenta actual de dos contadores:uno que se incrementa cada milisegundo y otro que lo hace cada microsegundo, por lo que si calculamos la diferencia entre ambos instantes (antes y después de la ejecución del comando) obtendremos el tiempo que ha tardado. Debido a que la longitud del array que es posible ordenar puede variar entre dos y 4096 elementos, el contador que utiliza el \comando{micros()} puede desbordar debido a que el tiempo de ejecución es mayor que el que puede alcanzar este contador y dar un valor incorrecto, por lo que es necesario utilizar \comando{millis()}. Tampoco sería posible usar solo \comando{millis()} al carecer de la precisión suficiente cuando se ordenan arrays cortos. El tiempo obtenido se envía al cliente y se muestra en la pantalla OLED del chipKIT I/O Shield. Además, durante la ejecución de un comando, el pin 70 de la placa microcontroladora (que corresponde al LED LD1 en el I/O Shield) se pone a nivel alto, lo que permite, no solo mostrar que se está ejecutando un comando, sino también medir el tiempo que permanece a nivel alto con un osciloscopio cuya sonda este conectada a este pin. 

Para automatizar el proceso de comparación entre los diferentes algoritmos y niveles de optimización, he incluido en el programa el comando \comando{comparar}. Este comando genera un array aleatorio de máxima longitud y lo ordena con cada uno de los comandos de ordenación disponibles, mostrando los resultados en pantalla.

En el apéndice \ref{chap:apendice3} se encuentra una descripción detallada del funcionamiento interno del programa.

\subsection{Funciones de ordenación}
Las funciones de ordenación que hemos comentado anteriormente, las que usa el programa par ordenar el array que le envíamos, se encuentran declaradas en el archivo \programa{funciones.h} y definidas en \programa{funciones.c}.

\subsubsection{Bubble Sort}
Este es el algoritmo más sencillo de los tres implementados. Se recorre el array comparando un elemento con el siguiente e intercambiándolos en el caso de que el primero sea mayor que el segundo. Para completar el ordenamiento es necesario recorrer el array varias veces.
\begin{lstlisting}[caption=Implementación de Bubble Sort]
void bubble0(int * array, int len) {
  int c, d, swap;

  for (c = 0; c < len; c++) {
    for (d = 0; d < (len - c - 1); d++) {
      if(array[d] > array[d+1]) {
        swap = array[d];
        array[d] = array[d+1];
        array[d+1] = swap;
      }
    }
  }
}  
\end{lstlisting}\label{Implementación de Bubble Sort en nuestro programa}

\subsubsection{Quick Sort}
En el algoritmo de ordenamiento rápido, se elige un elemento del array que denominaremos pivote. A la izquierda del pivote se colocan los elementos menores a él, mientras que a la derecha colocaremos los elementos mayores. De esta forma el elemnto `pivote' ocupará su posición final de la misma. Se repite el procedimiento de forma recursiva con los sub-arrays que quedan a la izquierda y a la derecha del pivote, hasta que todo el array esté ordenado. En el programa se ha optado por elegir como elemento `pivote' el primero del array.
\begin{lstlisting}[caption=Implementación de Quick Sort]
void quicksort0(int *v, int b, int t) {
  if(b < t) {
    int pivote = colocar0(v, b, t);
    quicksort0(v, b, pivote - 1);
    quicksort0(v, pivote + 1, t);
  }
}

int colocar0(int *v, int b, int t) {
  int i;
  int pivote, valor_pivote;
  int temp;

  pivote = b;
  valor_pivote = v[pivote];
  for (i = b + 1; i <= t; i++) {
    if (v[i] < valor_pivote) {
      pivote++;
      temp = v[i];
      v[i] = v[pivote];
      v[pivote] = temp;
    }
  }
  temp = v[b];
  v[b] = v[pivote];
  v[pivote] = temp;

  return pivote;
}
\end{lstlisting}

\subsubsection{Selection Sort}
El tercer algoritmo implementado en el programa es Selection Sort. Su funcionamiento consiste en recorrer el array, almacenándose el elemento de menor valor. Este elemento se extrae del array y se coloca al principio para, a continuación, volver a hacer lo mismo con el resto del array, hasta que esté ordenado.

\begin{lstlisting}[caption=Implementación de Selection Sort]
void selection0(int *array, int len) {
  for (int i = 0; i < len; ++i) {
    int index_of_min = i;
    for (int j = i; j < len; ++j) {
      if (array[index_of_min] > array[j]) {
        index_of_min = j;
      }
    }
    int temp = array[i];
    array[i] = array[index_of_min];
    array[index_of_min] = temp;
  }
}
\end{lstlisting}

\subsection{Análisis estático de la optimización en los algoritmos de ordenación.}
Una vez visto como están implementados los algoritmos de ordenación en C, podemos ver su aspecto una vez compilados y comparar entre los diferentes niveles de optimización y como afectan a estas funciones.

Comenzando con el algoritmo `Bubble Sort', tenemos en la figura \ref{bubble} el código de sus cuatro versiones para compararlas entre ellas.

\begin{figure}
\begin{center}
\begin{tabular}{c c}
	\begin{minipage}[t]{.5\textwidth}
		\begin{lstlisting}[caption=bubble0,basicstyle=\ttfamily\scriptsize, tabsize=2]
00000000 <_Z7bubble0Pii>:
   0:	18a00015 	blez	a1,58 <_Z7bubble0Pii+0x58>
   4:	24a5ffff 	addiu	a1,a1,-1
   8:	08000011 	j	44 <_Z7bubble0Pii+0x44>
   c:	240affff 	li	t2,-1
  10:	8c460000 	lw	a2,0(v0)
  14:	8c470004 	lw	a3,4(v0)
  18:	00e6402a 	slt	t0,a3,a2
  1c:	11000003 	beqz	t0,2c <_Z7bubble0Pii+0x2c>
  20:	24630001 	addiu	v1,v1,1
  24:	ac470000 	sw	a3,0(v0)
  28:	ac460004 	sw	a2,4(v0)
  2c:	0069302a 	slt	a2,v1,t1
  30:	14c0fff7 	bnez	a2,10 <_Z7bubble0Pii+0x10>
  34:	24420004 	addiu	v0,v0,4
  38:	24a5ffff 	addiu	a1,a1,-1
  3c:	10aa0006 	beq	a1,t2,58 <_Z7bubble0Pii+0x58>
  40:	00000000 	nop
  44:	18a0fffc 	blez	a1,38 <_Z7bubble0Pii+0x38>
  48:	00a04821 	move	t1,a1
  4c:	00801021 	move	v0,a0
  50:	08000004 	j	10 <_Z7bubble0Pii+0x10>
  54:	00001821 	move	v1,zero
  58:	03e00008 	jr	ra
  5c:	00000000 	nop
		\end{lstlisting}
	\end{minipage} 
	&
	\begin{minipage}[t]{.5\textwidth}
		\begin{lstlisting}[caption=bubble1, basicstyle=\ttfamily\scriptsize, tabsize=2]
00000000 <_Z7bubble1Pii>:
   0:	18a00015 	blez	a1,58 <_Z7bubble1Pii+0x58>
   4:	24a5ffff 	addiu	a1,a1,-1
   8:	08000011 	j	44 <_Z7bubble1Pii+0x44>
   c:	240affff 	li	t2,-1
  10:	8c460000 	lw	a2,0(v0)
  14:	8c470004 	lw	a3,4(v0)
  18:	00e6402a 	slt	t0,a3,a2
  1c:	11000003 	beqz	t0,2c <_Z7bubble1Pii+0x2c>
  20:	24630001 	addiu	v1,v1,1
  24:	ac470000 	sw	a3,0(v0)
  28:	ac460004 	sw	a2,4(v0)
  2c:	0069302a 	slt	a2,v1,t1
  30:	14c0fff7 	bnez	a2,10 <_Z7bubble1Pii+0x10>
  34:	24420004 	addiu	v0,v0,4
  38:	24a5ffff 	addiu	a1,a1,-1
  3c:	10aa0006 	beq	a1,t2,58 <_Z7bubble1Pii+0x58>
  40:	00000000 	nop
  44:	18a0fffc 	blez	a1,38 <_Z7bubble1Pii+0x38>
  48:	00a04821 	move	t1,a1
  4c:	00801021 	move	v0,a0
  50:	08000004 	j	10 <_Z7bubble1Pii+0x10>
  54:	00001821 	move	v1,zero
  58:	03e00008 	jr	ra
  5c:	00000000 	nop
		\end{lstlisting}
	\end{minipage} \\

	\begin{minipage}[t]{.5\textwidth}
		\begin{lstlisting}[caption=bubble2, basicstyle=\ttfamily\scriptsize, tabsize=2]
00000000 <_Z7bubble2Pii>:
   0:	18a00013 	blez	a1,50 <_Z7bubble2Pii+0x50>
   4:	24a5ffff 	addiu	a1,a1,-1
   8:	240affff 	li	t2,-1
   c:	58a0000e 	blezl	a1,48 <_Z7bubble2Pii+0x48>
  10:	24a5ffff 	addiu	a1,a1,-1
  14:	00801021 	move	v0,a0
  18:	00001821 	move	v1,zero
  1c:	8c460000 	lw	a2,0(v0)
  20:	8c470004 	lw	a3,4(v0)
  24:	24630001 	addiu	v1,v1,1
  28:	00e6482a 	slt	t1,a3,a2
  2c:	11200003 	beqz	t1,3c <_Z7bubble2Pii+0x3c>
  30:	0065402a 	slt	t0,v1,a1
  34:	ac470000 	sw	a3,0(v0)
  38:	ac460004 	sw	a2,4(v0)
  3c:	1500fff7 	bnez	t0,1c <_Z7bubble2Pii+0x1c>
  40:	24420004 	addiu	v0,v0,4
  44:	24a5ffff 	addiu	a1,a1,-1
  48:	14aafff0 	bne	a1,t2,c <_Z7bubble2Pii+0xc>
  4c:	00000000 	nop
  50:	03e00008 	jr	ra
  54:	00000000 	nop
		\end{lstlisting}
	\end{minipage}
	&
	\begin{minipage}[t]{.5\textwidth}
		\begin{lstlisting}[caption=bubble3, basicstyle=\ttfamily\scriptsize, tabsize=2]
00000000 <_Z7bubble3Pii>:
   0:	18a00013 	blez	a1,50 <_Z7bubble3Pii+0x50>
   4:	24a5ffff 	addiu	a1,a1,-1
   8:	240affff 	li	t2,-1
   c:	58a0000e 	blezl	a1,48 <_Z7bubble3Pii+0x48>
  10:	24a5ffff 	addiu	a1,a1,-1
  14:	00801021 	move	v0,a0
  18:	00001821 	move	v1,zero
  1c:	8c460000 	lw	a2,0(v0)
  20:	8c470004 	lw	a3,4(v0)
  24:	24630001 	addiu	v1,v1,1
  28:	00e6482a 	slt	t1,a3,a2
  2c:	11200003 	beqz	t1,3c <_Z7bubble3Pii+0x3c>
  30:	0065402a 	slt	t0,v1,a1
  34:	ac470000 	sw	a3,0(v0)
  38:	ac460004 	sw	a2,4(v0)
  3c:	1500fff7 	bnez	t0,1c <_Z7bubble3Pii+0x1c>
  40:	24420004 	addiu	v0,v0,4
  44:	24a5ffff 	addiu	a1,a1,-1
  48:	14aafff0 	bne	a1,t2,c <_Z7bubble3Pii+0xc>
  4c:	00000000 	nop
  50:	03e00008 	jr	ra
  54:	00000000 	nop
		\end{lstlisting}
	\end{minipage} \\
\end{tabular}
\label{bubble}
\end{center}
\caption{Implementaciones de `Bubble Sort' en ensamblador}
\end{figure}

