En este capítulo hablaré sobre los diferentes niveles de optimización que se pueden seleccionar durante la compilación y sus consecuencias en el programa final. Para ver dichas consecuencias se propondrá un programa que se ejecute en la placa microcontroladora y con el que se podrán medir los efectos de las optimizaciones. Por último se creará un programa que muestra las limitaciones de la biblioteca Arduino y que, además, está relacionado con las telecomunicaciones.
\section{Niveles de optimización}
Durante la compilación es posible especificar, mediante la opción \comando{-O} diferentes niveles de optimización. Estos niveles agrupan una serie de optimizaciones.

\begin{table}[H]
\begin{center}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    Nivel de optimización & Descripción\\
    \hline
    \hline
   	\comando{-O0} & Opción por defecto. Reduce el tiempo de compilación y facilita la depuración.\\
    \hline
    \comando{-O1} & Optimiza, pero aumenta el tiempo de compilación y la memoria empleada.\\
    \hline
    \comando{-O2} & Optimiza más todavía. \programa{GCC} realiza casi todas la optimizaciones que no impliquen aumento de la velocidad a costa de un mayor tamaño del programa.\\
    \hline
    \comando{-O3} & Optimiza todavía más que \comando{-O2}, incluyendo las optimizaciones que aumenten el tamaño del ejecutable.\\
    \hline
    \comando{-Os} & Optimiza el tamaño del programa. Habilita todas las optimizaciones de \comando{-O2} que normalmente no aumenten el tamaño del código y realiza más optimizaciones destinadas a reducir el tamaño del programa.\\
    \hline
  \end{tabularx}
\end{center}
\caption{Niveles de optimización}
\label{tab:optimizacionx}
\end{table}

Cada uno de estos niveles (a excepción de \comando{-Os}) añade una serie de optimizaciones sobre el nivel inicial \comando{-O0}.

Para poder averiguar que optimizaciones lleva acabo el compilador dependiendo del nivel podemos emplear el comando \comando{pic32-gcc -Ox -Q --help=optimizers | grep enabled} sustituyendo \comando{x} por el nivel que queramos. Esta orden muestra todos las posibles optimizaciones, indicando si están habilitadas o no y para ver solo las habilitadas pasamos el resultado a \comando{grep} para filtrarlas.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-loops & -fargument-alias\\
		-fbranch-count-reg & -fcommon\\
		-fdata-sections & -fdce\\
		-fdelete-null-pointer-checks & -fdse\\
		-fearly-inlining & -fgcse-lm\\
		-finline-functions-called-once & -fivopts\\
		-fjump-tables & -fmath-errno\\
		-fmove-loop-invariants & -fpeephole\\
		-frename-registers & -fsched-critical-path-heuristic\\
		-fsched-dep-count-heuristic & -fsched-group-heurisitc\\
		-fsched-interblock & -fsched-last-insn-heuristic\\
		-fsched-spec & -fsched-spec-insn-heuristic\\
		-fsched-stalled-insns-dep & -fsigned-zeros\\
		-fsplit-ivs-in-unroller & -ftoplevel-reorder\\
		-ftrapping-math & -ftree-cselim\\
		-ftree-forwprop & -ftree-loop-im\\
		-ftree-loop-ivcanon & -ftree-loop-optimize\\
		-ftree-phiprop & -ftree-pta\\
		-ftree-reassoc & -ftree-scev-cprop\\
		-ftree-slp-vectorize & -ftree-vect-loop-version\\
		-funit-at-a-time & -fvar-tracking\\
		-fvar-tracking-assignments & -fweb\\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones del nivel 0.}
\label{opt0}
\end{table}

En el nivel más bajo, \programa{gcc} ya realiza optimizaciones. Todas las optimizaciones que comienzan con \comando{-ftree} afectan al árbol sintáctico que utiliza \programa{gcc} como representación interna del programa. También se puede observar como una de las optimizaciones que incluye este nivel es \comando{-fdata-sections} y a pesar de esto \programa{MPIDE} la incluye explícitamente cuando ejecuta la compilación. Otro grupo de optimizaciones que ya aparecen en este nivel son las que comienzan \comando{-fsched} que afectan a la reordenación de instrucciones (en ensamblador) para aprovechar lo mejor posible la segmentación de instrucciones del procesador evitando ciclos de espera. En este nivel, si el programa tiene una función que solo es llamada una vez, su llamada será sustituida por el contenido de la función, directamente, gracias a la opción \comando{-finline-functions-called-once}.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-fcprop-registers & -fdefer-pop\\
		-fdelayed-branch & -fforward-propagate\\
		-fguess-branch-probability &-fif-conversion\\
		-fif-conversion2 & -fipa-pure-const\\
		-fipa-reference & -fmerge-constants\\
		-fomit-frame-pointer & -fsplit-wide-types\\
		-ftree-ccp & -ftree-ch\\
		-ftree-copy-prop & -ftree-copyrename\\
		-ftree-dce & -ftree-dominator-opts\\
		-ftree-dse & -ftree-fre\\
		-ftree-sink & -ftree-sra\\
		-ftree-ter & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O1' al nivel `O0'.}
\label{optimizaciones1}
\end{table}

En el nivel 1 se añaden más optimizaciones que afectan al arbol sintáctico, suponiendo estas casi la mitad de las nuevas optimizaciones. \comando{-fif-conversion} y \comando{-fif-conversion2} tienen como obejtivo tratar de transformar secciones de código donde se usan saltos condicionales para que no los requieran, reduciendo de esta forma el número de instrucciones. También encontramos aquí \comando{-fdelayed-branch} que intentará reordenar las instrucciones para aprovechar el tiempo que se pierde durante saltos condicionales. Si se produce una instrucción de salto condicional, no es posible saber cual es la instrucción que se debe ejecutar después hasta que acabe, por lo que normalmente la siguiente instrucción suele ser un \comando{nop}. Si el procesador lo soporta, se mueve una de las instrucciones anteriores a la instrucción de salto que no tenga ninguna dependencia con esta, para aprovechar el hueco libre. En lugar de colocar después del salto, una instrucción anterior, \programa{gcc} también trata de predecir, con la opción \comando{-fguess-branch-probability}, que se ejecutará despues por lo que este lugar lo ocupará la primera instrucción de uno de los destinos. Si la predicción resulta erronea, se descartará esta instrucción.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-functions & -falign-jumps\\
		-falign-labels & -fcaller-saves\\
		-fcrossjumping & -fcse-follow-jumps\\
		-fexpensive-optimizations & -fgcse\\
		-finline-small-functions & -fipa-cp\\
		-fipa-sra & -foptimize-register-move\\
		-foptimize-sibling-calls & -fpeephole2\\
		-fregmove & -fremove-local-statics\\
		-freorder-blocks & -freorder-functions\\
		-frerun-cse-after-loop & -fschedule-insns\\
		-fschedule-insns2 & -fstrict-aliasing\\
		-fthread-jumps & -ftree-builtin-call-dce\\
		-ftree-pre & -ftree-switch-conversion\\
		-ftree-vrp & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O2' al nivel `O1'.}
\label{optimizaciones2}
\end{table}

El nivel 2 incluye muchas más optimizaciones. En este nivel encontramos las optimizaciones \comando{-falign} que se encargan de alinear el comienzo de funciones, saltos y etiquetas (\comando{-falign-functions}, \comando{-falign-jumps} y \comando{-falign-labels}) en memoria. Su alineamiento en memoria supone una carga más rápida en detrimento del tamaño de la aplicación final, ya que se necesita añadir \comando{nop}s para que las funciones comiencen en bloques de N bytes, donde N depende del procesador.Con la opción \comando{-finline-small-functions} el contenido de las funciones pequeñas se copia en el lugar del código donde son llamadas. El requisito que deben cumplir estas funciones es que el espacio que ocupen al copiarse sea inferior al que sería ocupado si fuesen llamadas. De este modo, si usamos este nivel de optimización podemos escribir funciones triviales que nos ayuden a que el programa sea mas legible sin perder rendimiento ni espacio.

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-fgcse-after-reload & -finline-functions\\
		-fipa-cp-clone & -fpredictive-commoning\\
		-ftree-pre-partial-partial & -ftree-vectorize\\
		-funswitch-loops & \\
		\hline
	\end{tabular}
\end{center}
\caption{Optimizaciones que añade el nivel `O3' al nivel `O2'.}
\label{optimizaciones3}
\end{table}

En el nivel más alto \programa{gcc} considera todas las funciones para que su contenido sustituya a las llamadas a las mismas, gracias a la opción \comando{-finline-functions}. Es decir, ya no se sustituyen solo las funciones cuyo contenido sea menor que la sobrecarga que supone la llamada a la función. La consecuencia directa de está optimización es un aumento considerable del programa final y aumento del rendimiento al eliminar el código de llamada y retorno de una función. 

\begin{table}[H]
\begin{center}
	\begin{tabular}{|ll|}
		\hline
		-falign-functions & -falign-jumps\\
		-falign-loops & -falign-labels\\
		-freorder-blocks & -freorder-blocks-and-partition\\
		-fprefetch-loop-arrays & -ftree-vect-loop-version\\
		\hline
\end{tabular}
\end{center}
\caption{Optimizaciones del nivel `O2' que no se realizan en el nivel `Os'.}
\label{optimizaciones_s}
\end{table}

Las optimizaciones que lleva acabo el compilador cuando se activa la opción \comando{-Os} (Optimizar para el tamaño) son las mismas que cuando se usa \comando{-O2} a excepción de las que se encuentran en la tabla \ref{optimizaciones_s}. Estas optimizaciones son las que, aumentando el rendimiento, mas aumentan el tamaño de la aplicación final.

Cada nivel ofrece diferentes optimizaciones, aumentando el rendimiento con forme se aumenta el nivel. Es necesario valorar que nivel es el más adecuado para la aplicación. Por ejemplo, en un entorno empotrado (embedded) como sería el de un microcontrolador, debemos tener en cuenta la cantidad de memoria que tiene disponible al elegir la optimización del programa. Es posible elegir un nivel alto de optimización si el programa es pequeño y, por lo tanto, la memoria es suficiente. Si por el contrario la memoria es escasa se tendrá que elegir una optimización que no aumente el tamaño del programa. En el caso de depuración del código, el nivel más adecuado suele ser el más bajo ya que en este nivel, el compilador no modifica la estructura del programa, ni reordena instrucciones, haciendo más fácil la lectura del mismo en ensamblador.

Por último, es importante mencionar que se puede elegir un nivel de los cuatro disponibles y añadir más optimizaciones o quitarlas en la línea de comandos. Por ejemplo, sería posible elegir el nivel 3 de optimización, sin usar \comando{-finline-functions} añadiendo como argumento \comando{-fno-inline-functions}. Todas las opciones mencionadas antes se pueden negar añadiendo `no' a la opción. También podemos añadir optimizaciones que no se encuentran en ninguno de estos niveles, como \comando{-funroll-loops}\footnote{Esta opción `desenrolla' bucles, repitiendo el bloque de ejecución y reduciendo las veces que se ejecuta.} en la línea de comandos.

\section{Aplicación para ChipKIT}

Para ver los efectos de las optimizaciones que \programa{gcc} pueda efectuar, he creado una aplicación para ChipKIT. Se trata de un terminal al que podemos acceder de forma remota. Conectándonos a la placa a través de la red de área local tendremos acceso a un terminal básico en el que se pueden ejecutar varios comandos. La conexión se realiza utilizando el protocolo TCP en el puerto 23. He elegido este puerto al ser el estándar de Telnet aunque hubiese sido posible elegir cualquier otro. Para conectarse a la placa solo es necesario un programa que pueda establecer esta conexión, por lo que se puede usar el propio \programa{telnet} o \programa{netcat}. Con este último trabajamos directamente en la capa de transporte del modelo OSI, obviando todas las convenciones, procedimientos y comandos de la capa de aplicación.

Una vez establecida la conexión con la aplicación hay disponibles varios comandos que se pueden ejecutar. Se trata de comandos de ordenación en su mayoría, que permiten ordenar un array de números que se pasa como argumento del comando. Los elementos del array pueden estar separados por espacios, tabulaciones o comas. Dependiendo del nombre del comando, el array se ordena con un algoritmo determinado.
\begin{description}
	\item[\comando{bubble0}, \comando{bubble1}, \comando{bubble2}, \comando{bubble3}] Ordenan los números usando el algoritmo `Bubble Sort'.
	\item[\comando{quick0}, \comando{quick1}, \comando{quick2}, \comando{quick3}] Ordenan los números usando el algoritmo `Quick Sort'.
	\item[\comando{sel0}, \comando{sel1}, \comando{sel2}, \comando{sel3}] Ordenan los números usando el algoritmo `Selection Sort'.
	\item[\comando{comparar}] Reordena un array de números aleatorios usando todos los algoritmos anteriores.
	\item[\comando{help}] Muestra los comandos disponibles.
	\item[\comando{exit}] Cierra la conexión.
\end{description}

Por ejemplo, si quisieramos ordenar el vector [9 8 7 6 5 4 3 2 1] usando el algoritmo `Bubble Sort' escribiríamos lo siguiente:\footnote{Este vector representa el peor caso para este algoritmo (para esta longitud de vector), al estar los números ordenados de mayor a menor.}
\begin{lstlisting}
bubble0 9 8 7 6 5 4 3 2 1
\end{lstlisting}

El número que acompaña a cada uno de los comandos indica el nivel de optimización con el que han sido compilados, de este modo es posible probar el efecto de los distintos niveles sin tener que recompilar y volver a cargar el programa. Antes de llamar a la función de ordenación correspondiente, el programa llama a \comando{ReadCoreTimer()}. Está función devuelve el valor del registro \comando{COUNT} del coprocesador. El valor de este registro se incrementa cada dos ciclos de procesador, independientemente de lo que se esté ejecutando, por lo que se incrementa con una frecuencia de 40MHz. Cuando finaliza la ejecución de la función se vuelve a llamar a \comando{ReadCoreTimer()} y así obtenemos los ciclos que le ha llevado al procesador la ejecución de la función de ordenación. El traslado de este dato a unidades de tiempo en lugar de ciclos es inmediato, puesto que solo hay que multiplicarlo por la mitad del periodo del reloj principal, es decir, \(2.5*10^{-8}sec\).
El número de ciclos obtenido se envía al cliente y se muestra en la pantalla OLED del chipKIT I/O Shield. Además, durante la ejecución de un comando, el pin 70 de la placa microcontroladora (que corresponde al LED LD1 en el I/O Shield) se pone a nivel alto, lo que permite, no solo mostrar que se está ejecutando un comando, sino también medir el tiempo que permanece a nivel alto con un osciloscopio cuya sonda este conectada a este pin. 

Para automatizar el proceso de comparación entre los diferentes algoritmos y niveles de optimización, he incluido en el programa el comando \comando{comparar}. Este comando genera un array aleatorio de máxima longitud y lo ordena con cada uno de los comandos de ordenación disponibles, mostrando los resultados en pantalla.

En el apéndice \ref{chap:apendice3} se encuentra una descripción detallada del funcionamiento interno del programa.

\subsection{Funciones de ordenación}
Las funciones de ordenación que hemos comentado anteriormente, las que usa el programa par ordenar el array que le envíamos, se encuentran declaradas en el archivo \programa{funciones.h} y definidas en \programa{funciones.c}.

\subsubsection{Bubble Sort}
Este es el algoritmo más sencillo de los tres implementados. Se recorre el array comparando un elemento con el siguiente e intercambiándolos en el caso de que el primero sea mayor que el segundo. Para completar el ordenamiento es necesario recorrer el array varias veces.
\begin{lstlisting}[caption=Implementación de Bubble Sort]
void bubble0(int * array, int len) {
  int c, d, swap;

  for (c = 0; c < len; c++) {
    for (d = 0; d < (len - c - 1); d++) {
      if(array[d] > array[d+1]) {
        swap = array[d];
        array[d] = array[d+1];
        array[d+1] = swap;
      }
    }
  }
}  
\end{lstlisting}\label{Implementación de Bubble Sort en nuestro programa}

\subsubsection{Quick Sort}
En el algoritmo de ordenamiento rápido, se elige un elemento del array que denominaremos pivote. A la izquierda del pivote se colocan los elementos menores a él, mientras que a la derecha colocaremos los elementos mayores. De esta forma el elemnto `pivote' ocupará su posición final de la misma. Se repite el procedimiento de forma recursiva con los sub-arrays que quedan a la izquierda y a la derecha del pivote, hasta que todo el array esté ordenado. En el programa se ha optado por elegir como elemento `pivote' el primero del array.
\begin{lstlisting}[caption=Implementación de Quick Sort]
void quicksort0(int *v, int b, int t) {
  if(b < t) {
    int pivote = colocar0(v, b, t);
    quicksort0(v, b, pivote - 1);
    quicksort0(v, pivote + 1, t);
  }
}

int colocar0(int *v, int b, int t) {
  int i;
  int pivote, valor_pivote;
  int temp;

  pivote = b;
  valor_pivote = v[pivote];
  for (i = b + 1; i <= t; i++) {
    if (v[i] < valor_pivote) {
      pivote++;
      temp = v[i];
      v[i] = v[pivote];
      v[pivote] = temp;
    }
  }
  temp = v[b];
  v[b] = v[pivote];
  v[pivote] = temp;

  return pivote;
}
\end{lstlisting}

\subsubsection{Selection Sort}
El tercer algoritmo implementado en el programa es Selection Sort. Su funcionamiento consiste en recorrer el array, almacenándose el elemento de menor valor. Este elemento se extrae del array y se coloca al principio para, a continuación, volver a hacer lo mismo con el resto del array, hasta que esté ordenado.

\begin{lstlisting}[caption=Implementación de Selection Sort]
void selection0(int *array, int len) {
  for (int i = 0; i < len; ++i) {
    int index_of_min = i;
    for (int j = i; j < len; ++j) {
      if (array[index_of_min] > array[j]) {
        index_of_min = j;
      }
    }
    int temp = array[i];
    array[i] = array[index_of_min];
    array[index_of_min] = temp;
  }
}
\end{lstlisting}

\section{Análisis estático de la optimización en los algoritmos de ordenación.}
Una vez visto como están implementados los algoritmos de ordenación en C, podemos ver su aspecto una vez compilados y comparar entre los diferentes niveles de optimización y como afectan a estas funciones.

En el apéndice \ref{chap:apendice4} se encuentran las distintas funciones en lenguaje ensamblador, obtenido a partir del fichero objeto \comando{funciones.o} que se genera durante la compilación del programa. Se ha obtenido mediante el comando \comando{pic32-objdump -d funciones.o}.

\begin{table}[H]
	\begin{center}
	\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
Función	&	
Nº Ins.\tablefootnote{Número total de instrucciones que contiene la función.} & 
Ins. Aritméticas\tablefootnote{addiu,addu,andi,sll,subu,xori} & 
Ins. Ctrl. Flujo\tablefootnote{beq,beqz,blez,blezl,bne,bnez,j,jal,jr,slt} & 
Ins. Memoria\tablefootnote{lw,sw} & 
Otras\tablefootnote{li,move,movn} & 
NOPs\\
\hline
\hline
Bubble0 & 74 & 31.1\% & 12.2\% & 47.3\% & 2.7\% & 6.8\%\\
Bubble1 & 22 & 18.2\% & 36.4\% & 18.2\% & 18.2\% & 9.1\%\\
Bubble2 & 22 & 22.7\% & 36.4\% & 18.2\% & 13.6\% & 9.1\%\\
Bubble3 & 22 & 22.7\% & 36.4\% & 18.2\% & 13.6\% & 9.1\%\\
Colocar0 & 91 & 29.7\% & 6.6\% & 57.1\% & 2.2\% & 4.4\%\\
Colocar1 & 28 & 35.7\% & 25.0\% & 32.1\% & 7.1\% & 0.0\%\\
Colocar2 & 32 & 31.3\% & 25.0\% & 28.1\% & 15.6\% & 0.0\%\\
Colocar3 & 32 & 31.3\% & 25.0\% & 28.1\% & 15.6\% & 0.0\%\\
Quicksort0 & 38 & 10.5\% & 15.8\% & 50.0\% & 10.5\% & 13.2\%\\
Quicksort1 & 29 & 13.8\% & 20.7\% & 34.5\% & 27.6\% & 3.4\%\\
Quicksort2 & 28 & 14.3\% & 25.0\% & 28.6\% & 32.1\% & 0.0\%\\
Quicksort3 & 28 & 14.3\% & 25.0\% & 28.6\% & 32.1\% & 0.0\%\\
Selection0 & 74 & 24.3\% & 12.2\% & 52.7\% & 2.7\% & 8.1\%\\
Selection1 & 32 & 25.0\% & 31.3\% & 21.9\% & 18.8\% & 3.1\%\\
Selection2 & 28 & 21.4\% & 28.6\% & 14.3\% & 35.7\% & 0.0\%\\
Selection3 & 33 & 24.2\% & 30.3\% & 12.1\% & 30.3\% & 3.0\%\\
\hline
	\end{tabular}
\end{center}
	\caption{Número de instrucciones}
	\label{num_ins}
\end{table}

Observando la tabla \ref{num_ins} se pueden apreciar algunos patrones. El tamaño de la función, o el número de instrucciones\footnote{Son equivalentes ya que en MIPS todas las instrucciones son de longitud constante, no como, por ejemplo, en x86 donde puede variar su longitud.} decrece considerablemente cuando se aplica el primer nivel de optimización, llegando a reducirse hasta a un 30\% del tamaño inicial. En algunos casos el número de instrucciones aumenta cuando se usan el segundo o el tercer nivel ya que las optimizaciones que realiza el compilador no tienen como objetivo reducir el tamaño, solamente aumentar la velocidad de ejecución.

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}
\begin{axis}[
xlabel=Nivel de optimización,
ylabel=\% instrucciones de acceso a memoria,
grid=major,
xtick=data]
\addplot coordinates {
(0,47.3)
(1,18.2)
(2,18.2)
(3,18.2)
};
\addplot coordinates {
(0,57.1)
(1,32.1)
(2,28.1)
(3,28.1)
};
\addplot coordinates {
(0,50)
(1,34.5)
(2,28.6)
(3,28.6)
};
\addplot coordinates {
(0,52.7)
(1,21.9)
(2,14.3)
(3,12.1)
};
\legend{bubble,colocar,quicksort,selection}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Comparación de instrucciones de acceso a memoria entre funciones y optimizaciones.}
\label{graph:memoria}
\end{figure}

Si nos fijamos en la gráfica de la figura~\ref{graph:memoria}, vemos como en el nivel inicial de optimización el número de accesos a memoria supone alrededor de la mitad de las instrucciones totales de la funcion, reduciendose notablemente en los niveles superiores. Esta diferencia se debe, principalmente, al uso que se hace de los registros disponibles según el nivel de optimización. Por ejemplo, si vemos el código en ensamblador de \comando{bubble0} nos damos cuenta de que solamente hace uso de dos registros durante su ejecución: \comando{v0} y \comando{v1}. Por otro lado, en \comando{bubble1}, \comando{bubble2} y \comando{bubble3} se utilizan, no solo \comando{v0} y \comando{v1} sino también otros registros como \comando{a1}, \comando{a2} y \comando{a3}, aprovechando mejor los recursos disponibles en el procesador.

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}
\begin{axis}[
xlabel=Nivel de optimización,
ylabel=\% nops,
grid=major,
xtick=data]
\addplot coordinates {
(0,6.8)
(1,9.1)
(2,9.1)
(3,9.1)
};
\addplot coordinates {
(0,4.4)
(1,0)
(2,0)
(3,0)
};
\addplot coordinates {
(0,13.2)
(1,3.4)
(2,0)
(3,0)
};
\addplot coordinates {
(0,8.1)
(1,3.1)
(2,0)
(3,3.0)
};
\legend{bubble,colocar,quicksort,selection}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Comparación de instrucciones \comando{nop} entre funciones y optimizaciones.}
\label{graph:nops}
\end{figure}
El número de instrucciones \comando{nop}, como se aprecia en la figura~\ref{graph:nops}, supone un gran porcentaje en las funciones cuyo nivel de optimización es `0', pero se reduce en el resto de los niveles de optimización, con respecto al más bajo. En el caso del algoritmo `bubble sort' el porcentaje incrementa, esto quiere decir que el número de instrucciones \comando{nop} es superior en relación al número total de instrucciones en la función, sin embargo, este último número se reduce cuantiosamente (de 74 a 22 instrucciones). La cantidad de \comando{nop} en una función nos da una idea de la eficencia de la misma, ya que esta instrucción supone que el procesador no comienza una instrucción nueva en ese ciclo. El número es alto en el nivel inferior de optimización ya que el compilador no trata de reordenar las funciones para evitar dependencias entre ellas, lo que supone que el procesador deba esperar a que esté el dato disponible o a poder usar la unidad aritmético-lógica.

\subsection{Depuración y legibilidad del código.} % (fold)
\label{sub:Depuración y legibilidad del código.}
A partir del primer nivel de optimización el tamaño de la función y los tipos de instrucciones en ensamblador que podemos encontrar, no varan mucho. Sin embargo si que se producen reordenamiento de las instrucciones por parte del compilador para aprovechar mejor las unidades funcionales del microprocesador. Esto tiene la desventaja de que, a la hora de depurar el código ensamblado, es más difícil relacionar las instrucciones en lenguaje MIPS con las correspondientes en C. Es por esto que durante la fase de desarrollo del programa se debe mantener el nivel de optimización más bajo posible para facilitar la tarea de depuración.

Esto se puede observar en las funciones desensambladas del apéndice~\ref{chap:apendice4}. Por ejemplo, en las funciones que han sido compiladas usando el nivel de optimización `0', detrás de las instrucciónes de salto condicional siempre encontramos un \comando{nop}. Sin embargo, en el resto, debido a la opción \comando{-fdelayed-branch} encontramos en su lugar instrucciones que se ejecutarían antes sino se hubiese usado esta opción. Esto puede dar lugar a confusión cuando se revisa el código (sobretodo si no se está familiarizado con estas optimizaciones y el modelo de programación de MIPS).

La desventaja de leer y depurar el código compilado sin optimizaciones es el exceso de movimientos entre el stack y los registros que se producen. Si acudimos otra vez al ejemplo de la función \comando{bubble0}, se puede ver como, durante toda la función, se guardan continuamente los valores de los registros \comando{v0} y \comando{v1} en el stack y, a continuación, se vuelven a leer. Esto no ocurre en el resto de funciones ya que en estás se hace más uso de los registros y menos del stack.
% subsection Depuración y legibilidad del código. (end)

\section{Análisis del tiempo de ejecución.} % (fold)
\label{sec:Análisis del tiempo de ejecución.}
Ya hemos visto el aspecto de las funciones en ensamblador, la cantidad de instrucciones en cada una de ellas y el tipo de instrucciones que las componen. Pero, ¿cómo se traducen estas diferencias en el rendimiento final de la aplicación?. ¿Hasta que punto merece la pena el aumento de la complejidad del código ensamblador?.

\begin{mymdframed}{Nota}
	Normalmente, el nivel de optimización con el que se compila un programa también afecta al propio tiempo de compilación del mismo. Debido al tamaño de programa que se trata aquí (el archivo que se carga a la placa de Sorted, el programa en el que se encuentran las funciones de ordenación, ocupa solamente 314kbytes y su compilación tarda 3 segundos en mi portátil), este hecho se obvia al no tener un gran impacto en el proceso de creación de un programa para chipKIT o Arduino.
\end{mymdframed}

Hay varias formas de determinar el rendimiento de un programa o función. Podemos, por ejemplo, medir cuantos cálculos realiza por unidad de tiempo, pero esta medida no es adecuada para el este tipo de aplicación. En este caso lo que se intenta conseguir (en términos de rendimiento y optimización) es reducir el retardo que se produce desde que el usuario envía el comando hasta que obtiene la respuesta. Por lo que para saber el rendimiento de cada función y nivel de optimización, se usará el tiempo que tarda en ejecutarse dicha función, que será el tiempo de respuesta de la aplicación.\footnote{Cuando se ejecuta un comando este debe ser procesado, al igual que el vector de números que se pasa como parámetro, pero este tiempo será constante en todas las funciones al ser su código común a todas ellas.}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}
\begin{axis}[
xlabel=Nivel de optimización,
ylabel=Ciclos / 2,
grid=major,
xtick=data]
\addplot coordinates {
	(0,193490006)
	(1,39335390)
	(2,34581721)
	(3,34372868)
};
\addplot coordinates {
	(0,	14248406)
	(1,	2982945)
	(2,	2361030)
	(3,	2082368)
};
\addplot coordinates {
	(0,	122092276)
	(1,	46284313)
	(2,	37895014)
	(3,	50483369)
};
\legend{Bubble,Quicksort,Selection}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de ciclos según función y optimización}
\label{graph:ciclos}
\end{figure}

En la figura~\ref{graph:ciclos} están representados la cantidad de ciclos de procesador que ha llevado ejecutar cada una de las funciones según el nivel de optimización. Se observa un patrón claro, al reducirse el tiempo de ejecución considerablemente cuando se utiliza el primer nivel de optimización, con respecto al inicial. Por ejemplo en el caso del algoritmo `Bubble Sort' esta reducción supone un 80\% menos de ciclos tan solo eligiendo el primer nivel de optimización. En los otros dos algoritmos se aprecia también un descenso del tiempo de ejecución, aunque en el caso de `Quicksort' es mucho más discreto que en los otros dos, sin embargo, ya en el nivel de optimización `0' ya es más rápido.

Si nos fijamos en la ganancia de rendimiento para niveles de optimización más altos que el primero, se puede ver que es muy inferior a la que se obtiene con el primer nivel (en comparación al nivel `0'). Este resultado es de esperar debido a que las optimizaciones que se llevan a cabo en los niveles superiores son más específicas y en estos algoritmos no tienen gran efecto. En el caso del algoritmo de selección, además, vemos como, no solo no se reduce el tiempo de ejecución al usar el tercer nivel de optimización, sino que aumenta con respecto al primer y segundo nivel. Este comportamiento no lo vemos en las otras funciones que, aunque muy limitada, si presentan una ganancia en el rendimiento final.
\begin{table}[htb]
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|}
			\hline
			Algoritmo & Nivel 0 & Nivel 1 & Nivel 2 & Nivel 3 \\
			\hline
			\hline
			Bubble		&	386980012	&	78670780 (80\%)	&	69163442 (12\%)	&	68745736 (0.6\%) \\
			\hline
			QuickSort	&	28496812	&	5965890	(79\%)	&	4722060 (21\%)	&	4164736 (12\%) \\
			\hline
			Selection &	244184552	&	92568626 (62\%)	&	75790028 (18\%)	&	100966738 (-33\%) \\
			\hline
		\end{tabular}
	\end{center}
\caption{Algoritmos y ciclos de ejecución. Ganancia con respecto al nivel anterior entre paréntesis.}
\label{tabla:ciclos}
\end{table}
% section Análisis del tiempo de ejecución. (end)
\section{Limitaciones de la biblioteca Arduino.} % (fold)
\label{sec:Limitaciones de la biblioteca Arduino.}

La plataforma Arduino, incluyendo ChipKIT, está pensada para poder crear programas sin tener que conocer el funcionamiento interno de cada microcontrolador. Es una capa de abstracción más, que permite usar las mismas funciones o incluso programas en microcontroladores diferentes. Por ejemplo, si ejecutamos la función \comando{digitalWrite(13, HIGH)} sabemos que se encenderá el LED de usuario que tienen instalado todas las placas convencionales compatibles con Arduino. No es necesario conocer a que puerto del microcontrolador está conectado dicho LED, que varía según el modelo de placa. Por ejemplo, en el chipKIT MAX32 este LED (LD4) se encuentra conectado al tercer pin del puerto A, sin embargo, en el chipKIT Uno32 lo encontramos el el sexto pin del puerto G.

Cuando queremos leer un valor en una de las entradas analógicas ocurre algo similar: a la función \comando{analogRead()} solo hay que pasarle el pin de la placa, cuyo número se encuentra impreso al lado del mismo y la función se encarga de realizar toda la configuración necesaria para obtener el valor del ADC.

Esta simplificación tiene un precio. Cada vez que se quiere leer o escribir en cada uno de estos puertos, la función encargada de hacerlo lleva a cabo la configuración y la posterior lectura o escritura. Esta sobrecarga hace que cualquiera de estas operaciones sea considerablemente más lenta que si se realizara con funciones de más bajo nivel o accediendo directamente a los registros.

Para ilustrar la diferencia he medido de dos formas distintas la frequencia a la que es capaz el chipKIT Max32 de cambiar el estado de un pin de salida. Usando la funcion de Arduino para escribir en una salida digital (\comando{digitalWrite()}) y accediendo a los registros directamente he generado dos ondas cuadradas de diferentes frecuencias. La primera forma de medir la diferencia ha sido usando un método similar al que usamos en el apartado anterior: guardando el valor del contador del microprocesador antes y después de la ejecución de lo que se desea medir. En este caso he optado por medir el tiempo que tarda en ejecutarse un bucle `for' en el que se pone a alto y bajo un pin del microcontrolador. El bucle se repite \(10^5\) veces.

\begin{table}[htb]
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|c|}
			\hline
			Método		&		Cuentas		&		Ciclos		&		Ciclos/iteración	&		Periodo		&		Frecuencia \\
			\hline
			\hline
			Arduino		&		5763684		&		11527368	&		115.27						&		1.44 us		&		694 kHz \\
			\hline
			Registros	&		501040		&		1002080		&		10.02							&		125.26 ns	&		7.98 MHz \\
			\hline

		\end{tabular}
	\end{center}
	\caption{Diferencia entre \comando{digitalWrite()} y acceso directo al registro usando un bucle \comando{for} de $10^5$ iteraciones y midendo el tiempo que tarda en completarse este bucle.}
	\label{ard_vs_reg:1}
\end{table}

En la figura~\ref{ard_vs_reg:1} se puede apreciar la diferencia de velocidad cuando se realiza la escritura digital en un puerto dependiendo del método empleado. Según estos datos el acceso directo a los registros del microcontrolador nos otorga la posibilidad de ejecutar esta operación a una frecuencia un orden de magnitud mayor que con la función \comando{digitalWrite()} de la biblioteca Arduino. Para contrastar los resultados también he obtado por realizar las mediciones con otro método. Usando un bucle infinito con \comando{while(1)} he medido la frecuencia de la onda cuadrada que se genera en el pin correspondiente y, como se puede ver en la figura~\ref{ard_vs_reg:2} los resultados son muy similares al primer método.

\begin{table}[htb]
	\begin{center}
		\begin{tabular}{|l|c|}
			\hline
			Método		&		Frecuencia	\\
			\hline
			\hline
			Arduino		&		700 kHz			\\
			\hline
			Registros	&		7.983	MHz		\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Frecuencia de conmutación según el método empleado. Medida usando un multímetro UNI-T UT61E}
	\label{ard_vs_reg:2}
\end{table}

Esta diferencia de velocidad dependiendo del método empleado es debida a que las funciones de la biblioteca Arduino no se encargan solo de, por ejemplo, escribir en un pin digital, también comprueban que el pin existe y en el caso de existir, a que puerto del microcontrolador pertenece. Como el objetivo de la biblioteca Arduino no es solo simplificar funciones comunes en microcontroladores, sino también generar código portable, es decir, código que pueda ser compilado en diferentes microcontroladores, las funciones deben ser capaces de ejecutarse teniendo en cuenta esto. Cuando usamos registros la velocidad aumenta, como ya he dicho, a expensas de reducir la legibilidad del código y su portabilidad.

Otra limitación de Arduino es la falta de funciones para controlar características de cada microcontrolador, como por ejemplo interrupciones y temporizadores. Si queremos hacer uso de alguna de estas características no queda más remedio que acudir a las funciones del fabricante o directamente a los registros del microcontrolador. Otro ejemplo de este tipo de limitación está presente en el programa escrito para la siguiente sección. En este programa se muestrea de forma regular (a 8 kHz) una entrada analógica. Esto no es posible realizarlo con la función de Arduino \comando{analogRead()} ya que es demasiado lenta, al tener que configurar cada vez el pin de entrada. Usando los registros del microcontrolador podemos configurar el ADC para que tome muestras de forma regular~\footnote{En el caso del chip que incorpora el chipKIT Max32 se pueden alcanzar frecuencias de muestreo de 1Msps.} y autónoma, generando una interrupción cuando la muestra está lista.
% section Limitaciones de la biblioteca Arduino. (end)
\section{Ejemplo de aplicación relacionada con la carrera de telecomunicación.} % (fold)
\label{sec:Ejemplo de aplicación relacionada con la carrera de telecomunicación.}

% section Ejemplo de aplicación relacionada con la carrera de telecomunicación. (end)
