% -*-cap1.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

\section{Contexto} % (fold)
% Arduino
% Microcontroladores
% Internet of Things
% Segunda revolución del garaje
%
\label{sec:Contexto}
Un microcontrolador es un circuito integrado que se compone de varios bloques funcionales como una CPU, memoria o periféricos y además es programable. Con ayuda de algunos componentes externos, junto con el microcontrolador, se pueden crear pequeños circuitos que realicen tareas determinadas, que pueden ir desde controlar la temperatura de un recipiente mediante sensores y ventiladores hasta facilitar el manejo de un avión teledirigido.

En 1971 Intel creó el primer microcontrolador de la histora: el intel 4004 de 4 bits. Desde entonces, los microcontroladores han ido evolucionando hasta los modelos de hoy en día. En la acutalidad existen multitud de modelos diferentes entre los que elegir. Su arquitectura puede ser diferente dependiendo del fabricante o, dentro de este, de la gama. Por ejemplo, Microchip utiliza una arquitectura para su gama de 32 bits diferente al resto de gamas más bajas.

Para programar un microcontrolador, no solo hay que conocer el lenguaje de programación adecuado, normalmente C y en algunos casos ensamblador, sino que también hay que estar familiarizado con el funcionamiento del modelo concreto que se vaya a programar. No es lo mismo programar un microcontrolador ARM que un PIC32 o un Atmel AVR. A pesar de que en todos ellos se utiliza C, las instrucciones y registros en cada uno de ellos difiere.

En el año 2003, se comenzó a trabajar en la plataforma Wiring, en el instituto IVREA, en Italia. Con esta plataforma se pretendía lograr facilitar la programación de microcontroladores. Dos años más tarde, nació Arduino que, junto con Wiring, ofrecía una plataforma de hardware y software abierto con la que cualquier persona, con unos conocimientos básicos de programación, podía crear sus propios proyectos.
% section Contexto (end)

\section{Introducción}
A lo largo de la carrera he aprendido a programar diferentes dispositivos y arquitecturas. Comencé usando el lenguaje C en ordenadores x86.  Más adelante cursé `Sistemas Electronicos Digitales', asignatura en la que trabajé con ensamblador.  El microprocesador en el que se ejecutaban los programas era el conocido Motorola 68000.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[
		decoration={
			markings,
			mark=at position 1 with {\arrow[ultra thick]{latex}},
		},
		path/.style={
			postaction=decorate,
		},
%		every node/.style={font=\sffamily}
	]
	% Boxes
	\node [
		draw,
		xshift=-6cm,
		minimum width=2cm,
	] (hid_in) {HID};
	\node [
		draw,
		minimum width=2cm,
		minimum height=2cm,
	] (pc) {PC};
	\node [
		draw,
		xshift=6cm,
		minimum width=2cm,
	] (hid_out) {HID};
	\node [
		draw,
		xshift=-6cm,
		yshift=1cm,
		minimum width=2cm,
] (mem_in) {Memoria};
	\node [
		draw,
		xshift=6cm,
		yshift=1cm,
		minimum width=2cm,
] (mem_out) {Memoria};
	\node [
		draw,
		xshift=-6cm,
		yshift=-1cm,
		minimum width=2cm,
] (net_in) {Red};
	\node [
		draw,
		xshift=6cm,
		yshift=-1cm,
		minimum width=2cm,
] (net_out) {Red};

% Conexiones
\draw[path] (mem_in.east) -- ++(2,0) node[above,pos=0.3]{digital} |- ([yshift=-0.5cm] pc.north west);
\draw[path] (hid_in.east) -- ++(2,0) node[above,pos=0.3]{digital} |- (pc.west);
\draw[path] (net_in.east) -- ++(2,0) node[below,pos=0.3]{digital} |- ([yshift=0.5cm] pc.south west);

\draw[path] ([yshift=-0.5cm] pc.north east) -- ++(2,0)  |- node[above,pos=0.7]{digital}(mem_out.west);
\draw[path] (pc.east) -- ++(2,0) |- node[above,pos=0.7]{digital} (hid_out.west);
\draw[path] ([yshift=0.5cm] pc.south east) -- ++(2,0) |- node[below,pos=0.7]{digital} (net_out.west);

\end{tikzpicture}
\end{center}
\caption{Origen y Destino de los datos procesados en un Ordenador}
\label{io_pc}
\end{figure}
%mimateo: lo de STDIN no estoy seguro ni que de naciera en UNIX. Lo que sí tengo claro es que se usa en muchos más sistemas operativos, de ahí la modificación que he realizado
Usando esta plataforma tuve la posibilidad de programar un sistema donde el flujo de datos era diferente a lo que había visto hasta ese momento.  En un ordenador convencional los datos que recibe el programa pueden provenir de tres fuentes diferentes: la memoria, el usuario o la red, siendo estas mismas fuentes el lugar donde se enviaba el resultado.  Sin embargo, usando este microprocesador tuve la oportunidad de obtener los datos, no desde un fichero o la entrada estándar (`STDIN'\footnote{Normalmente está asociado al teclado en un programa de terminal, teclado controlado por ese programa o por el sistema operativo.}) sino desde un teclado que tenía que configurar, desde el puerto serie o incluso a través de un convertidor analógico-digital (ADC).  En vez de enviar los datos recibidos y procesados de forma similar a un PC convencional, era posible mostrarlos en una pantalla de siete segmentos o accionando un motor.
 
\begin{figure}[H]
%mimateo: en este figura falta una salida analógica pura
\begin{center}
\begin{tikzpicture}[
		decoration={
			markings,
			mark=at position 1 with {\arrow[ultra thick]{latex}},
		},
		path/.style={
			postaction=decorate,
		},
%		every node/.style={font=\sffamily}
	]
	% Boxes
	\node [
		draw,
		xshift=-6cm,
		minimum width=2cm,
	] (hid_in) {HID};
	\node [
		draw,
		xshift=-6cm,
		yshift=2.5cm,
		minimum width=2cm,
		text width = 5cm,
	] (sensores) {Sensores: audio, temperatura, humedad, luz \dots};
	\node [
		draw,
		xshift=-6cm,
		yshift=-2.5cm,
		minimum width=2cm,
		text width = 5cm,
	] (conexiones) {Conexiones Serie/paralelo: SPI, UART, Wire, CAN \dots};
	\node [
		draw,
		minimum width=2cm,
		minimum height=3cm,
	] (uc) {\(\mu\)  C};
	\node [
		draw,
		xshift=6cm,
		yshift=2.5cm,
		minimum width=2cm,
		text width=5cm,
	] (otros) {Otros elementos digitales: LEDs, Relés \dots};
	\node [
		draw,
		xshift=6cm,
		minimum width=2cm,
	] (hid_out) {HID};
	\node [
		draw,
		xshift=-6cm,
		yshift=1cm,
		minimum width=2cm,
	] (mem_in) {Memoria};
	\node [
		draw,
		xshift=6cm,
		yshift=1cm,
		minimum width=2cm,
	] (mem_out) {Memoria};
	\node [
		draw,
		xshift=-6cm,
		yshift=-1cm,
		minimum width=2cm,
	] (net_in) {Red};
	\node [
		draw,
		xshift=6cm,
		yshift=-1cm,
		minimum width=2cm,
	] (net_out) {Red};
	\node [
		draw,
		xshift=6cm,
		yshift=-2cm,
		minimum width=2cm,
	] (pwm) {PWM};
	\node [
		draw,
		xshift=5cm,
		yshift=-3.5cm,
		minimum width=2cm,
		text width=5cm,
	] (otros_analog) {Elementos analógicos: Altavoces, Buzzers, LEDs \dots};

% Conexiones
\draw[path] (sensores.east) -- ++(2,0) node[above,pos=0.5]{analógico} |- ([yshift=-0.5cm] uc.north west);
\draw[path] (mem_in.east) -- ++(2,0) node[above,pos=0.3]{digital} |- ([yshift=-1cm] uc.north west);
\draw[path] (hid_in.east) -- ++(2,0) node[above,pos=0.3]{digital} |- (uc.west);
\draw[path] (net_in.east) -- ++(2,0) node[below,pos=0.3]{digital} |- ([yshift=1cm] uc.south west);
\draw[path] (conexiones.east) -- ++(2,0) node[below,pos=0.5]{digital} |- ([yshift=0.5cm] uc.south west);

\draw[path] ([yshift=-0.5cm] uc.north east) -- ++(1,0)  |- node[above,pos=0.7]{digital}(otros.west);
\draw[path] ([yshift=-1cm] uc.north east) -- ++(2,0)  |- node[above,pos=0.7]{digital}(mem_out.west);
\draw[path] (uc.east) -- ++(2,0) |- node[above,pos=0.7]{digital} (hid_out.west);
\draw[path] ([yshift=1cm] uc.south east) -- ++(2,0) |- node[below,pos=0.7]{digital} (net_out.west);
\draw[path] ([yshift=0.5cm] uc.south east) -- ++(1,0) |- node[below,pos=0.7]{digital} (pwm.west);
\draw[path] (pwm.east) -- ++(1,0) node[above]{analógico} |-  (otros_analog.east);

\end{tikzpicture}
\end{center}
\caption{Origen y Destino de los datos procesados en un Microcontrolador}
\label{io_uc}
\end{figure}
Esta plataforma tenía dos inconvenientes que hacían inviable su uso fuera de un entorno de aprendizaje o profesional.  Primero, era necesario programar todo en ensamblador, no pudiendo usar las abstracciones que nos otorga un lenguaje como C, o al menos no se podía hacer de una forma sencilla.  Además, el kit que se usaba en clase es difícil de encontrar y, en el caso de hacerlo, su precio es prohibitivo, superando los 1000\$\footnote{http://www.promaxprolink.com/training/tm683.htm}.  Ese mismo año también realicé prácticas de programación con VHDL en FPGAs que también tenían los mismos problemas que el Motorola 68000: alto precio y programación de muy bajo nivel.

Un año más tarde conocí la plataforma Arduino, a raíz de la presentación del Arduino ADK. La plataforma presentada se componía de una placa con un microcontrolador Atmel2560 de 8 bits y era de un tamaño mucho menor que los kits que había usado a lo largo de la carrera.  El precio era de 60\euro{} para este modelo, que es el más caro y aún así mucho más asequible que las plataformas de prototipado que he mencionado.  
Uno de los aspectos más importantes de Arduino es que se puede programar usando C o C++ y contar con un entorno de desarrollo que permite la utilización de múltiples funciones que hacen posible programar a un nivel más alto que al que se haría si usáramos las herramientas que proporciona Atmel para sus microcontroladores.  No es necesario conocer el microcontrolador para llevar a cabo proyectos en Arduino.  Por ejemplo, para programar el parpadeo de un LED todo lo que hay que saber es a que pin (numerados en la placa) está conectado el diodo LED.

El hardware y el software de Arduino son abiertos.  Es posible obtener los esquemáticos de cualquier placa Arduino desde su página web y la biblioteca principal (en la que se basa cualquier proyecto Arduino) viene incluida con el entorno de programación como código fuente.  Con Arduino existe la posibilidad de comprar una placa oficial a través de su tienda o algún distribuido, pero también es posible construirla uno mismo.  Es posible también encontrar placas personalizadas a través de Internet, que lleven caracterísiticas no incluidas en las oficiales o que sean más baratas.

En este trabajo emplearé una placa compatible con Arduino: ChipKIT MAX32.  A diferencia de las placas Arduino convencionales, la gama ChipKIT de Digilent tiene como microcontrolador un PIC de 32 bits en vez de un Atmega de 8 bits.  Está placa ofrece más potencia y más prestaciones como por ejemplo la posibilidad de depurar nuestro programa gracias al conector JTAG que lleva incorporado. Comentaré las diferencias más a fondo en el siguiente capítulo.

\section{Objetivos}
Podemos dividir los objetivos de la siguiente forma:

\subsubsection{Proceso de compilación}
Lo primero que realizaré será un análisis del proceso que se sigue en el entorno de desarrollo de ChipKIT desde que escribimos el programa hasta que este esté funcionando en la placa microcontroladora.  Esto incluye todos los comandos o programas que intervengan en este proceso y sus respectivas opciones, además de los ficheros involucrados.

Para lograr flexibilidad en este proceso, propondré una alternativa al IDE que hará uso de Makefiles y me permitirá realizar todo el proceso anterior con un solo comando. También podré generar resultados intermedios, como por ejemplo el código compilado, pero no ensamblado, y podré modificar las opciones de cada uno de los comandos.

\subsubsection{Niveles de optimización}
El compilador ofrece diferentes niveles de optimización y según el nivel se llevan a cabo unas u otras optimizaciones. Uno de los objetivos será identificar estas optimizaciones y ver su efecto en el código. Usando una aplicación desarrollada para el microcontrolador pondré de manifiesto las diferencias entre los distintos niveles de optimización, que ventajas y que desventajas tienen cada uno de ellos.

\subsubsection{Limitaciones de la biblioteca Arduino}
La biblioteca Arduino nos ofrece una capa de abstracción sobre las funciones específicas del microcontrolador pero que tiene limitaciones. Comprobaré la diferencia entre usar esta biblioteca o acudir a las bibliotecas del fabricante, en este caso Microchip.

\subsubsection{Desarrollo de una aplicación enfocada en el ámbito de las telecomunicaciones}
Desarrollaré una aplicación en la que se pondrán en práctica conceptos relacionados con las telecomunicaciones, aprendidos durante la carrera. La función de la aplicación será detectar tonos mediante el uso del algoritmo de Goertzel.


\section{Estructura de la memoria}
Este trabajo se organiza en diferentes capítulos en los que trataré temas específicos.

\subsubsection{Arduino y ChipKIT}
En esta sección describiré y compararé las características de Arduino y ChipKIT y el motivo de haber elegido el segundo. Más concretamente me centraré en el Arduino Mega ADK y el ChipKIT MAX32. Este último es el que se usa a lo largo del trabajo mientras que el primero es su equivalente Arduino.

\subsubsection{Entorno de desarrollo}
Aquí hablaré del entorno de desarrollo de Arduino y de chipKIT, viendo las diferencias entre ellos y como funcionan internamente. Veremos que programas usan para compilar, ensamblar, enlazar y cargar los programas en la placa. Con esta información propondré una alternativa que me permita automatizar y modificar este proceso.

\subsubsection{Ejemplos de utilización}
Al compilar un programa tenemos la posibilidad de elegir diferentes niveles de optimización. Analizaré cuales son, que beneficios aportan y que desventajas tienen. Mediré las diferencias entre los distintos niveles en dos aplicaciones que crearé para tal propósito. La segunda de las aplicaciones estará relacionada con el ámbito de la carrera y tendrá como objetivo el procesamiento de señales, haciendo las funciones de un DSP.

\subsubsection{Conclusiones}
Terminaré con mis conclusiones, tanto técnicas como personales acerca de lo elaborado durante todo el trabajo.
