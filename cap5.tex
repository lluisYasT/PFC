En este capítulo expondré las conclusiones obtenidas durante la elaboración de este trabajo. Las conclusiones se han dividido en dos conjuntos: las coclusiones técnicas y las personales. En las  conclusiones técnicas comentaré los resultados del proyecto: cumplimiento de los objetivos, las mediciones obtenidas y el proceso usado para obtenerlas. En el apartado de conclusiones personales expondré mis pensamientos acerca de este trabajo y qué creo que he aprendido durante su realización.

\subsection{Conclusiones técnicas}

% Vamos a ver... 
% Esto son conclusiones, no puedes ir diciendo con pelos y señales lo que has hecho.
% Es mejor que te centres en los resultados obtenidos haciendo enlaces a las secciones 
% donde describes el proceso llevado a cabo.
% Lo que SÍ que tienes que haces es decir si se ha alcanzado este objetivo o no.
% Obejtivos técnios:
%  1º) Analizar el proceso de compilación del MPIDE
%  2º) Averiguar el efecto de los diferentes niveles de optimización
%  3º) Demostrar las limitaciones de Arduino (biblioteca)
%  4º) Desarrollo de una aplicación en el ámbito de las telecomunicaciones.
%
% ¿Por qué no empieza con este lístado, tal cual, y luego vas diciendo si se ha alcanzado
% o no?
% 

El primer objetivo de este trabajo era analizar el proceso de compilación, enlazado y carga en la placa que el IDE de Microchip (\programa{MPIDE}) lleva a cabo de forma transparente al usuario, para ,una vez conocido este proceso, desarrollar un método alternativo que permitiera la misma transparencia pero mayor flexibilidad incluso sin utilizar dicho entorno. Usando la opción de mostrar las órdenes ejecutadas en \programa{MPIDE} pude ver los programas a los que llama y en que orden. A partir de esta información ideé un archivo \orden{Makefile} que realizara las mismas acciones y que diese como resultado el programa cargado en la placa. Más tarde expandí la idea de un archivo Makefile a la creación de una plantilla de programa, es decir, una organización de carpetas en las que organizar las bibliotecas de terceros que pueda necesitar el programa, el código fuente y el ejecutable final. Fue interesante comprobar como había algunas acciones que el IDE llevaba a cabo antes de comenzar la compilación. A la hora de escribir un sketch en \programa{MPIDE} no es necesario declarar las funciones auxuiliares que pueda requerir la aplicación, a diferencia de como se haría en un programa normal escrito en C o C++. El IDE hace esta labor por el usuario, buscando las funciones que se hayan escrito en el sketch y añadiendo su definición al principio del mismo antes de comenzar la compilación. A parte de esto también añade un `include' con el archivo de cabecera que contiene todas las definiciones de las funciones de la biblioteca `core'.

El segundo objetivo planteado era comparar el efecto de los distintos niveles de optimización tenían sobre el rendimiento final del programa. Para esto se proponía la creación de un programa en el que se pudiese realizar esta comparación. El programa tiene como principal objetivo la ordenación de números usando diferentes algoritmos de ordenación, cada uno de ellos compilado con los cuatro principales niveles de optimización. El programa es accesible a través de la red, usando una conexión TCP en el puerto 21, es posible conectarse usando \programa{telnet} o \programa{netcat}. El programa presenta una línea de comandos en la que podemos llamar las distintas funciones pasando como argumento la lista de números a ordenar. El programa está creado usando como base la plantilla creada como parte del primer objetivo y, por lo tanto, fue posible desarrollarlo sin necesidad de abrir el IDE de ChipKIT en ningún momento, tan solo haciendo uso de las bibliotecas que incluye y de la \orden{toolchain} con la que se instala. Debido a la naturaleza del programa y usando \programa{netcat} es posible ordenar conjuntos de hasta 8192 números leyéndo la orden y los números desde un fichero y enviándoselos usando \programa{netcat}, sin necesidad de tener que escribirlos uno a uno. El problema principal a la hora de llevar a cabo esto es que los bytes que recibe el programa a través de la red se almacenan en un buffer de tan solo 1000 bytes por lo que era necesario ir leyendo el contenido de este y recibiendo más datos hasta encontrar un retorno de carro o salto de línea, punto en el que el programa asume que finaliza la órden.

Los resultados después de realizar las mediciones fueron los esperados. Cuando se aplicaba el primer nivel de optimzación el rendimiento era considerablemente mejor a la misma función sin optimizar. Aumentando el nivel de optimización mas allá solo suponía una pequeña mejora en el segundo nivel siendo práctimante despreciable en el tercero e incluso empeorando en algún caso. 

Una vez hecho esto, el siguiente objetivo era poner de manifiesto las limitaciones de la biblioteca Arduino frente a funciones de más bajo nivel que el fabricante provea en una biblioteca o directamente usando los registros del procesador y de periféricos. Para esto se utilizó el programa del LED parpadeante. Una versión de este se hizo usando las funciones que nos proporciona la biblioteca de Arduino para escribir en las salidas digitales, mientras que la otra versión se hizo modificando el valor de los registros de periféricos directamente reduciendo considerablemente la sobrecarga que conllevan todas las operaciones que se realizan en la biblioteca de Arduino. El resultado es una diferencia en frecuencia de apagado y encendido del LED de más de un orden de magnitud. Hay que tener en cuenta que al hacer uso de los registros del microcontrolador directamente se pierde la portabilidad que proporciona el uso de la biblioteca, de forma que el segundo programa solo es usable en el modelo concreto de microcontrolador para el que fue programado, mientras que la versión de Arduino puede funcionar en una amplía variedad de dispositivos sin necesidad de realizar ningún cambio.

Por último, se proponía la creación de un programa que pusiese en práctica conocimientos adquiridos durante la carrera. El programa tendría como objetivo detectar la presencia de un tono en una entrada analógica cuya señal se obtendría con un micrófono. Como ya se comentó en su correspondiente apartado, se eligió este programa porque permite poner en práctica conocimientos de procesamiento de señales adquiridos durante la carrera. El resultado ha sido un programa con un funcionamiento análogo al de un DSP, en el que se toma una muestra y esta se procesa antes de tomar la muestra siguiente para, al terminar el muestreo, realizar el cálculo final y obtener el valor. Bajo unas condiciones similares al DSP utilizado durante la carrera, el microcontrolador era capaz de obtener el mismo rendimiento que el dispositivo de Analog Devices, procesando muestras a 8kHz, con la ventaja de ser más barato, fácil de programar y multipropósito.

\subsection{Conclusiones personales}

% yo empezaría las conclusiones con esta frase.
En general, la realización de este proyecto me ha parecido un trabajo muy interesante y variado.


% ya se que lo has dicho antes, pero recuerda dónde has puesto la lista de asignaturas relacionadas.
% si no has puesto esa lista antes, sería el momento de ponerlas.

En este trabajo he tenido la posibilidad de poner en práctica los conocimientos adquiridos a lo largo de toda la carrera. Me ha servido para aplicar los conceptos, no sólo de una asignatura en concreto, sino los de varias de ellas. De esta forma he podido ver la relación entre las mismas y como se relacionan entre ellas. Esto es algo que no había podido hacer hasta este momento, ya que en el resto 
de trabajos realizados durante el transcurso de la carrera se solían centrar en la asignatura para la que se desarrollaban o una parte de ella.

% Latex, Git : esto hay que citar de donde lo has sacado y añadir entradas en la bibliografia...

No sólo he tenido que aplicar los conocimientos adquiridos en la carrera sino que también me he visto en la necesidad de aprender otros nuevos para poder llevar a cabo este trabajo. Por ejemplo, esta memoria está escrita usando Latex. Hasta ahora no había utilizado nunca este lenguaje de marcado por lo que he tenido que aprender ha usarlo. Otro ejemplo de conocimiento adquirido sería el uso del software de control de versiones Git que me ha permitido llevar un registro de las modificaciones hechas en la memoria. También ha sido de gran utilidad a la hora de desarrollar los programas para este trabajo ya que otorga gran flexibilidad a la hora de corregir errores o de implementar nuevas características sin “romper” la versión estable del programa.

Este trabajo también ha sido el de mayor envergadura que he llevado a cabo. Nunca antes he realizado un trabajo de tanta magnitud e importancia. Esto ha supuesto todo un reto para mi, sobre todo a la hora de escribir la memoria que es la parte que mas me ha costado.

%Y ahora una línea final de conclusion
A nivel personal este trabajo ha resultado gratificante/interesante/coñazo y con el que he pulido/completado mi formación como Ingeniero de Telecomunicación.