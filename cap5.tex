En este capítulo expondré las conclusiones obtenidas durante la elaboración de este trabajo. Se subdivide en dos apartados: conclusiones técnicas, donde comentaré los resultados de las mediciones y el proceso usado para obtenerlas; conclusiones personales, donde expondré mis pensamientos acerca de este trabajo junto con las cosas que he podido aprender durante la realización del mismo.

\subsection{Conclusiones técnicas}
Este trabajo tenía diferentes objetivos. El primero de ellos era analizar el proceso de compilación, enlazado y carga en la placa que lleva a cabo el IDE de Microchip (\programa{MPIDE}) de forma transparente al usuario. Una vez conocido este proceso había que desarrollar un método alternativo que me permitiera más transparencia y flexibilidad. Usando la opción de mostrar las órdenes ejecutadas en \programa{MPIDE} pude ver los programas a los que llama y en que orden. A partir de esta información ideé un archivo \orden{Makefile} que realizara las mismas acciones y que diese como resultado el programa cargado en la placa. Más tarde expandí la idea de un archivo Makefile a la creación de una plantilla de programa, es decir, una organización de carpetas en las que organizar las bibliotecas de terceros que pueda necesitar el programa, el código fuente y el ejecutable final. Fue interesante comprobar como había algunas acciones que el IDE llevaba a cabo antes de comenzar la compilación. A la hora de escribir un sketch en \programa{MPIDE} no es necesario declarar las funciones auxuiliares que pueda requerir la aplicación, a diferencia de como se haría en un programa normal escrito en C o C++. El IDE hace esta labor por el usuario, buscando las funciones que se hayan escrito en el sketch y añadiendo su definición al principio del mismo antes de comenzar la compilación. A parte de esto también añade un `include' con el archivo de cabecera que contiene todas las definiciones de las funciones de la biblioteca `core'.

El segundo objetivo planteado era comparar el efecto de los distintos niveles de optimización tenían sobre el rendimiento final del programa. Para esto se proponía la creación de un programa en el que se pudiese realizar esta comparación. El programa tiene como principal objetivo la ordenación de números usando diferentes algoritmos de ordenación, cada uno de ellos compilado con los cuatro principales niveles de optimización. El programa es accesible a través de la red, usando una conexión TCP en el puerto 21, es posible conectarse usando \programa{telnet} o \programa{netcat}. El programa presenta una línea de comandos en la que podemos llamar las distintas funciones pasando como argumento la lista de números a ordenar. El programa está creado usando como base la plantilla creada como parte del primer objetivo y, por lo tanto, fue posible desarrollarlo sin necesidad de abrir el IDE de ChipKIT en ningún momento, tan solo haciendo uso de las bibliotecas que incluye y de la \orden{toolchain} con la que se instala. Debido a la naturaleza del programa y usando \programa{netcat} es posible ordenar conjuntos de hasta 8192 números leyéndo la orden y los números desde un fichero y enviándoselos usando \programa{netcat}, sin necesidad de tener que escribirlos uno a uno. El problema principal a la hora de llevar a cabo esto es que los bytes que recibe el programa a través de la red se almacenan en un buffer de tan solo 1000 bytes por lo que era necesario ir leyendo el contenido de este y recibiendo más datos hasta encontrar un retorno de carro o salto de línea, punto en el que el programa asume que finaliza la órden.

Los resultados después de realizar las mediciones fueron los esperados. Cuando se aplicaba el primer nivel de optimzación el rendimiento era considerablemente mejor a la misma función sin optimizar. Aumentando el nivel de optimización mas allá solo suponía una pequeña mejora en el segundo nivel siendo práctimante despreciable en el tercero e incluso empeorando en algún caso. 

Una vez hecho esto, el siguiente objetivo era poner de manifiesto las limitaciones de la biblioteca Arduino frente a funciones de más bajo nivel que el fabricante provea en una biblioteca o directamente usando los registros del procesador y de periféricos. Para esto se utilizó el programa del LED parpadeante. Una versión de este se hizo usando las funciones que nos proporciona la biblioteca de Arduino para escribir en las salidas digitales, mientras que la otra versión se hizo modificando el valor de los registros de periféricos directamente reduciendo considerablemente la sobrecarga que conllevan todas las operaciones que se realizan en la biblioteca de Arduino. El resultado es una diferencia en frecuencia de apagado y encendido del LED de más de un orden de magnitud. Hay que tener en cuenta que al hacer uso de los registros del microcontrolador directamente se pierde la portabilidad que proporciona el uso de la biblioteca, de forma que el segundo programa solo es usable en el modelo concreto de microcontrolador para el que fue programado, mientras que la versión de Arduino puede funcionar en una amplía variedad de dispositivos sin necesidad de realizar ningún cambio.

Por último, se proponía la creación de un programa que pusiese en práctica conocimientos adquiridos durante la carrera. El programa tendría como objetivo detectar la presencia de un tono en una entrada analógica cuya señal se obtendría con un micrófono. Como ya se comentó en su correspondiente apartado, se eligió este programa porque permite poner en práctica conocimientos de procesamiento de señales adquiridos durante la carrera. El resultado ha sido un programa con un funcionamiento análogo al de un DSP, en el que se toma una muestra y esta se procesa antes de tomar la muestra siguiente para, al terminar el muestreo, realizar el cálculo final y obtener el valor. Bajo unas condiciones similares al DSP utilizado durante la carrera, el microcontrolador era capaz de obtener el mismo rendimiento que el dispositivo de Analog Devices, procesando muestras a 8kHz, con la ventaja de ser más barato, fácil de programar y multipropósito.

\subsection{Conclusiones personales}

En general, ha sido un trabajo muy interesante en el que he tenido que poner en práctica conocimientos de diferentes áreas adquiridos durante la carrera, además de necesitar otros nuevos.
%C
%Electronica
%Latex
%Git
%Procesado de señales
%Makefiles
%Ensamblador


