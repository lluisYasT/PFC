En este capítulo expondré las conclusiones obtenidas durante la elaboración de este trabajo. Se subdivide en dos apartados: conclusiones técnicas, donde comentaré los resultados de las mediciones y el proceso usado para obtenerlas; conclusiones personales, donde expondré mis pensamientos acerca de este trabajo junto con las cosas que he podido aprender durante la realización del mismo.

\subsection{Conclusiones técnicas}
Este trabajo tenía diferentes objetivos. El primero de ellos era analizar el proceso de compilación, enlazado y carga en la placa que lleva a cabo el IDE de Microchip (\programa{MPIDE}) de forma transparente al usuario. Una vez conocido este proceso había que desarrollar un método alternativo que me permitiera más transparencia y flexibilidad. Usando la opción de mostrar las órdenes ejecutadas en \programa{MPIDE} pude ver los programas a los que llama y en que orden. A partir de esta información ideé un archivo \orden{Makefile} que realizara las mismas acciones y que diese como resultado el programa cargado en la placa. Más tarde expandí la idea de un archivo Makefile a la creación de una plantilla de programa, es decir, una organización de carpetas en las que organizar las bibliotecas de terceros que pueda necesitar el programa, el código fuente y el ejecutable final. Fue interesante comprobar como había algunas acciones que el IDE llevaba a cabo antes de comenzar la compilación. A la hora de escribir un sketch en \programa{MPIDE} no es necesario declarar las funciones auxuiliares que pueda requerir la aplicación, a diferencia de como se haría en un programa normal escrito en C o C++. El IDE hace esta labor por el usuario, buscando las funciones que se hayan escrito en el sketch y añadiendo su definición al principio del mismo antes de comenzar la compilación. A parte de esto también añade un `include' con el archivo de cabecera que contiene todas las definiciones de las funciones de la biblioteca `core'.

El segundo objetivo planteado era comparar el efecto de los distintos niveles de optimización tenían sobre el rendimiento final del programa. Para esto se proponía la creación de un programa en el que se pudiese realizar esta comparación.

Una vez hecho esto, el siguiente objetvio era poner de manifiesto las limitaciones de la biblioteca Arduino frente a funciones de más bajo nivel que el fabricante provea en una biblioteca o directamente usando los registros del procesador y de periféricos.

Por último, se proponía la creación de un programa que pusiese en práctica conocimientos adquiridos durante la carrera. El programa tendría como objetivo detectar la presencia de un tono en una entrada analógica cuya señal se obtendría con un micrófono.
