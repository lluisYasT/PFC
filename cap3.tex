Cuando hablamos de entorno de desarrollo normalmente nos referimos al conjunto de procedimientos y herramientas para desarrollar, probar y depurar aplicaciones o programas.

En un entorno de desarrollo es común encontrar ciertas herramientas básicas: un editor de texto más o menos avanzado, una suite de compilación, un entorno de depuración y, para el caso de los microcontroladores, un programador.

Podemos diferenciar dos tipos de entorno de desarrollo: los entornos clásicos y los entornos de desarrollo integrados. En la forma clásica de entorno de desarrollo se utilizan de forma explicita herramientas independientes. Por ejemplo, si queremos desarrollar un programa escrito en C, podemos escribirlo usando \programa{Vim} o \programa{Emacs}, compilarlo usando \programa{gcc} y por último, depurarlo con herramientas como \programa{gdb} o \programa{valgrind}.

Por otro lado, en los entornos de desarrollo integrados o IDE (Integrated Development Environment)  aúnan todas las herramientas en un mismo interfaz de usuario, del que no es necesario salir en todo el proceso de desarrollo del programa. En algunos casos las herramientas son las mismas que en los entornos clásicos pero el IDE las oculta. Hay multitud de ejemplos de IDEs, como \programa{Eclipse}~\footnote{\url{http://www.eclipse.org/}} o \programa{Netbeans}~\footnote{\url{https://netbeans.org/}}, por citar algunos.

\section{MPLAB X}
\programa{MPLAB X}~\cite{website:mplab} es la última versión del entorno de desarrollo integrado que proporciona Microchip para programar sus microcontroladores. Este IDE, basado en el entorno de código abierto Netbeans, nos permite escribir nuestro programa, compilarlo, programar el microcontrolador y, con la ayuda de un depurador como los mencionados en el capítulo anterior, depurar el programa.

Aunque un IDE es mucho más que un editor de texto, el entorno de edición suele ser la herramienta más utilizada. El editor que incorpora \programa{MPLAB X} realiza el sangrado de las líneas de código automáticamente, identifica las parejas de corchetes, comillas, etc.\@ y enfatiza el texto con colores de forma tanto sintáctica como semántica. También dispone de plantillas de código y consejos.

\programa{MPLAB X} ofrece también una fácil gestión de proyectos y de archivos dentro de un mismo proyecto. En la parte izquierda del IDE podemos encontrar una sección en la que se encuentran los proyectos y sus archivos, ordenados de forma jerárquica, lo que ayuda en la gestión de diferentes proyectos en un mismo entorno.

\figura{mplab_descr.png}{scale=0.30}{MPLABX Depurando el programa Blink}{mplab}{H}

Como se aprecia en la Figura~\ref{mplab}, \programa{MPLAB X} nos ofrece mucha información. En esta figura vemos a \programa{MPLAB X} en mitad de la depuración del programa Blink~\footnote{Este programa es el equivalente en microcontroladores al `Hola Mundo', su única función es hacer parpadear un LED.}. En la zona superior del programa se encuentra el menú principal, que contiene los botones para crear un nuevo proyecto, abrirlo o guardarlo. También incluye todos los botones dedicados a la depuración: empezar o parar la depuración, ir a la siguiente instrucción, etc. En la parte izquierda se puede apreciar dos secciones diferentes. La superior muestra la organización del proyecto y la lista de proyectos en caso de que hubiese más de uno. Debajo de esto se encuentra toda la información acerca del estado actual del dispositivo seleccionado durante la creación del proyecto, en este caso un PIC32MX795F512L, como por ejemplo la cantidad de memoria RAM y flash que requiere la aplicación para funcionar comparado con la cantidad total de la que dispone el microcontrolador. En la parte central, y ocupando la mayor parte de la ventana, observamos el editor con el que se puede modificar los archivos de código fuente del proyecto. Por último, en la zona inferior, se encuentra el área de mensajes, consola e información del estado del proyecto. En este caso en particular está mostrando el estado del depurador. En esta zona también se puede mostrar el valor de variables del proyecto en tiempo real y el estado de los registros del procesador, entre otros.

El IDE dispone de muchas más herramientas para la depuración de programas. Durante la ejecución del mismo en modo depuración se pueden establecer puntos en el el código fuente donde el programa debe detener su ejecución, conocidos por su nombre en inglés: breakpoints. Se utilizan para detener la ejecución y así poder ver o modificar el estado de la memoria y registros del procesador en ese momento, ejecutar el programa línea a línea del código fuente o instrucción a instrucción en el código ensamblador, comprobar la traducción a ensamblador hecha por el compilador, etc.

Con este entorno de desarrollo veremos más adelante los diferentes efectos que los distintos niveles de optimización tienen en nuestro programa y podremos usarla para hacer profiling.

\section{Arduino IDE}
% Wiring y processing
% gcc
% bibliotecas incluidas
% Otros programas
% Multiplataforma
Para realizar proyectos en la plataforma Arduino es necesario disponer del entorno de desarrollo `Arduino IDE' que es posible encontrar en la página web de Arduino. Este programa está basado en Wiring\footnote{\url{http://wiring.org.co/}}, que a su vez nació a partir de Processing\footnote{\url{http://processing.org/}} por lo que el aspecto del mismo es prácticamente idéntico en todos ellos.

Processing se creó como una plataforma para facilitar la creación de programas sencillos, que muestren resultados de forma visual en un monitor. Usando esta plataforma como base, nació Wiring, que tenía un objetivo similar pero centrado en los microcontroladores.~\footnote{En el blog de Marlon J. Manrique podemos encontrar un buen artículo sobre Wiring: \url{http://www.marlonj.com/blog/2011/06/ques-es-wiring/}.}

Las diferencias entre \programa{Wiring} y el IDE de Arduino radican en el funcionamiento interno. Arduino IDE tiene incluido todo lo necesario para poder escribir, compilar, ensamblar, enlazar y cargar los programas a la placa Arduino, por lo que el usuario solo debe abrir el IDE, escribir su programa y darle al botón de ejecución; el IDE se encargará de compilar, enlazar y cargar el programa en la placa microcontroladora. Este proceso lo he descrito con más detalle en su propio apartado.

Si accedemos a la carpeta de instalación de Arduino veremos diferentes subcarpetas, donde se guardan diferentes componentes necesarios para su funcionamiento.
\begin{figure}[H]
\begin{center}
\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
	\node{Arduino}
		child { node {examples}}
		child { node {hardware}
			child { node {arduino}
				child { node {bootloaders}}
				child { node {cores}}
				child { node {firmwares}}
				child { node {variants}}
			}
			child [missing] {}
			child [missing] {}
			child [missing] {}
			child [missing] {}
			child { node {tools}
				child { node {avr}}
			}
			child [missing] {}
		}
		child [missing] {}
		child [missing] {}
		child [missing] {}
		child [missing] {}
		child [missing] {}
		child [missing] {}
		child [missing] {}
	child { node {lib}}
	child { node {libraries}}
	child { node { reference}};
\end{tikzpicture}
\end{center}
\caption{Estructura de directorios del entorno de programación de Arduino}
\label{arduino_carpetas}
\end{figure}

\begin{description}
	\item[\orden{examples}] El programa incluye algunos ejemplos que se pueden compilar y cargar sin modificarlos.
	\item[\orden{hardware}] En esta carpeta se guarda todo lo relacionado con el hardware, como su nombre indica. Aquí encontraremos la `toolchain' y las bibliotecas necesarias para la compilación y ensamblado de los programas Arduino.
	\item[\orden{lib}] Contiene bibliotecas Java para el funcionamiento del entorno de desarrollo.
		\item[\orden{libraries}] El IDE incluye algunas bibliotecas de terceros que se pueden incluir en nuestros proyectos.
		\item[\orden{reference}] Contiene toda la documentación.
\end{description}

En la carpeta \orden{hardware} encontramos otras dos carpetas: \orden{arduino} y \orden{tools}.  La primera contiene bootloaders, firmwares, la biblioteca `core' y en el directorio \orden{variants} están los archivos de cabecera de cada placa microcontroladora en los que se especifica la posición de cada periférico y pin según el microcontrolador.  En \orden{tools} está avrdude (utilidad para cargar los programas en la placa) y su archivo de configuración junto con la `toolchain' \programa{GCC} para realizar la compilación cruzada de los programas.

\section{\programa{MPIDE}}
% Igual que arduino
% Gcc pic32
\programa{MPIDE}\cite{website:mpide} es el IDE creado por Digilent para el entorno ChipKIT. Su diseño es idéntico al IDE de Arduino, variando solamente el color y el compilador usado.

\figura{mpide.jpg}{scale=0.6}{\programa{MPIDE}}{mpide}{H}

Si accedemos a la carpeta \orden{hardware} de este programa, encontramos otra carpeta además de \orden{arduino} y \orden{tools}: \orden{pic32}. La estructura es similar  a la de la carpeta de Arduino. Aquí están todas las bibliotecas para la plataforma ChipKIT. También podemos encontrar aquí la `toolchain' \programa{GCC} para pic32 en el directorio \orden{compiler}.

\begin{figure}
\begin{center}
\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\begin{tikzpicture}[%
grow via three points={one child at (0.5,-0.7) and
two children at (0.5,-0.7) and (0.5,-1.4)},
edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
\node{hardware}
	child { node {arduino}
		child { node {bootloaders}}
		child { node {cores}}
		child { node {firmwares}}
		child { node {variants}}
	}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child { node {pic32}
		child { node {compiler}}
		child { node {cores}}
		child { node {libraries}}
		child { node {variants}}
	}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child { node {tools}
		child { node {avr}}
	}
	child [missing] {};
\end{tikzpicture}
\end{center}
\caption{Estructura de directorios de hardware en la carpeta de instalación de MPIDE}
\label{mpide_carpetas}
\end{figure}

Estos entornos de desarrollo, tanto el de Arduino como el de ChipKIT, son fáciles de utilizar por su interfaz simple, pero carecen de muchas características de otros entornos como podrían ser Eclipse o incluso Vim con plugins. El editor no dispone de autocompletado ni de atajos u órdenes especiales para moverse por el archivo. Para configurar alguna opción, como la fuente empleada o su tamaño hay que recurrir a editar el archivo de configuración directamente.

Al igual que el entorno de Arduino, no es posible depurar programas.  No se puede hacer una ejecución paso a paso, ver el código ensamblador producido o ver el contenido de la memoria y su estado.  Si queremos depurar el programa de forma rudimentaria es necesario, por ejemplo, enviar por el puerto serie los valores de las variables que queramos controlar o mensajes cuando algo no funciona como debe. Tampoco muestra por defecto el proceso que sigue para compilar el programa.

En definitiva, ambos programas están pensados para proporcinar un entorno sencillo y accesible para todo tipo de usuarios.

\section{Estructura de un programa Arduino}
En cualquier programa para ChipKIT o Arduino podemos encontrar tres grupos principales de código fuente.
\subsection{Core}
Para empezar, tenemos los archivos que formarán parte de la biblioteca ``Core'' a la hora de la compilación. Estos archivos vienen incluidos con \programa{MPIDE} y los podemos encontrar en el directorio en el que tengamos instalado \programa{MPIDE}~\protect\footnote{La carpeta de \programa{MPIDE} la podemos colocar donde queramos, pues no requiere instalación}: en la subcarpeta\\
\orden{hardware/pic32/cores/pic32}

\begin{table}[H]
\begin{center}
\begin{tabular}{ll}
  \textbf{Sistema Operativo} & \textbf{Ruta}\\
	\midrule
  \textit{Linux} & /home/lluis/mpide/hardware/pic32/cores/pic32\\
  \textit{Mac OSX} & /Applications/Mpide.app/Contents/Resources/Java/hardware/pic32/cores/pic32\\
  \textit{Windows} & C:\textbackslash{}Archivos de Programa\textbackslash{}\programa{MPIDE}\textbackslash{}hardware\textbackslash{}pic32\textbackslash{}cores\textbackslash{}pic32\\
\end{tabular}
\end{center}
\caption{Ruta de la biblioteca Core}
\label{tab:core_path}
\end{table}

En esta biblioteca tenemos ya definidas las funciones que necesitamos para interactuar con los dispositivos que están integrados en la placa (en nuestro caso, ChipKIT Max32). Para más información acerca de estas funciones y cómo utilizarlas podemos acudir a la página de referencia de Arduino~\cite{website:arduino_funcs}. Además, en esta biblioteca está ya definida la función main de nuestro programa y tiene el siguiente aspecto:

\lstset{language=C++}
\begin{lstlisting}[caption=main.cpp]
#define OPT_SYSTEM_INTERNAL
#include <System_Defs.h>

#if (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

int main(void) {
init();
setup();

while(1) {
	_scheduleTask();
	loop();
}
return 0;
}
\end{lstlisting}

La función \orden{\_scheduleTask()} forma parte del módulo de administración de tareas de la biblioteca de Arduino y se encarga de ejecutar las tareas periódicas del procesador. Podemos encontrar su definición y una breve descripción de su funcionamiento en el archivo `task\_manager.c' junto con el resto de funciones de este módulo.

\subsection{Sketch}
Los programas que escribimos usando \programa{MPIDE} (o el IDE de Arduino) se llaman sketches. En realidad, no escribimos un programa completo porque, como acabamos de ver, el programa en sí ya está escrito en la biblioteca Core. Nuestro objetivo es implementar dos funciones: \orden{setup()} y \orden{loop()}, que ya están declaradas en el archivo de cabecera wiring.h.

\begin{lstlisting}[caption=Sección de wiring.h]
void setup(void);
void loop(void);
\end{lstlisting}

Como se puede apreciar en la declaración de ambas funciones, estas no esperan ni devuelven ningún valor.

\lstinputlisting[language=C++, caption=Sketch básico ("BareMinimum.pde")]{codigo_fuente/BareMinimum.pde}
En \orden{setup()} colocaremos el código para la inicialización de nuestro programa. Es el lugar donde podemos configurar el puerto serie, por ejemplo, o definir cómo se comportarán los pines (entrada o salida), entre otras cosas. En definitiva, es el lugar donde debemos colocar el código que queramos que se ejecute una vez al inicio del programa y que no vuelva a ejecutarse más.

En \orden{loop()} pondremos el código que se ejecutará de forma cíclica indefinidamente ya que, como podemos observar en \orden{main.cpp}, la función \orden{loop()} se encuentra dentro de un bucle infinito.

Veamos como ejemplo el sketch Blink:
\lstinputlisting[language=C++, caption=Blink.pde, label=code:blink]{codigo_fuente/Blink.pde}

En este sketch utilizamos las funciones de Arduino \orden{pinMode}, \orden{digitalWrite} y \orden{delay}. En la función \orden{setup()} inicializamos el puerto al que está conectado el LED como una salida~\protect\footnote{PIN\_LED1 está definido en el archivo de cabecera Board\_Defs.h que depende del modelo de microcontrolador que estemos usando. Generalmente, este es el LED que se encuentra en la propia placa, conectado al pin 13.}, mientras que en \orden{loop()} encendemos y apagamos el LED con retardos de 1 segundo.

\subsection{Bibliotecas de terceros}
Aparte del código de Arduino y del que creemos nosotros, también es posible añadir bibliotecas de terceros. Gracias a la amplia comunidad que hay detrás de Arduino podemos encontrar cientos de ellas. A la hora de usar una biblioteca de Arduino en ChipKIT tendremos que asegurarnos de que no haga uso de funciones específicas de los procesadores Atmel que encontramos en las placas Arduino, ya que no funcionarán en PIC32.

Cuando trabajamos con \programa{MPIDE} podemos encontrar las bibliotecas en dos sitios diferentes. \programa{MPIDE} tiene incluidas varias bibliotecas que podemos encontrar en el directorio ``libraries'' dentro de la carpeta en la que esté instalado \programa{MPIDE}. Aparte de estas bibliotecas, podemos instalar bibliotecas que descarguemos de Internet o que creemos nosotros dentro de la carpeta ``libraries'' en el directorio \orden{sketchbook}~\protect\footnote{La carpeta ``libraries'' no existe. Es necesario crearla dentro del directorio \orden{sketchbook}.} que \programa{MPIDE} habrá creado la primera vez que lo ejecutemos.

Con las bibliotecas instaladas en uno de los dos directorios podremos añadirlas a nuestro programa de dos formas diferentes. Podemos añadirlas usando el menú de MPIDE, pudiéndolas encontrar en \orden{Sketch > Import Library}. También es posible usar la directiva \orden{\#include <[Archivo De Cabezera].h>} como haríamos en cualquier programa escrito en C/C++. \programa{MPIDE} se encargará de compilar las bibliotecas y enlazarlas con nuestro programa.

\section{Proceso de compilación de \programa{MPIDE}}
\label{sec:compilacion}
En este apartado he tratado de describir el proceso que sigue \programa{MPIDE} para la compilación y posterior carga en el microcontrolador del programa creado en \programa{MPIDE}\@. Nuestro objetivo será saber que programas y opciones de compilación usa el IDE de ChipKIT\@.

\tikzstyle{format} = [draw, thin, fill=blue!20]
\tikzstyle{medium} = [ellipse, draw, thin, fill=green!20, minimum height=2.5em]
\begin{figure}[htb]
  \begin{tikzpicture}[node distance=3cm, auto,>=latex', thick]
    % We need to set at bounding box first. Otherwise the diagram
    % will change position for each frame.
    %\path[use as bounding box] (-1,0) rectangle (10,-2);
    \path[->]node[](start){};
    \path[->]node[format,below of=start] (preproc) {Preprocesador}
    (start) edge node {.c .cpp} (preproc);
    \path[->]node[format, right of=preproc] (comp) {Compilador}
    (preproc) edge node {.i} (comp);
    \path[->]node[format, right of=comp] (ensam) {Ensamblador}
    (comp) edge node {.S} (ensam);
    \path[->]node[format, right of=ensam] (enlaz) {Enlazador}
    (ensam) edge node {.o} (enlaz);
    \path[->]node[format, right of=enlaz] (carga) {Carga en Placa}
    (enlaz) edge node {.elf} (carga);
    %\path[->, draw](preproc) -- +(0,1) -| node[near start] {ensam\TeX} (ensam);
  \end{tikzpicture}
  \caption{Proceso de compilación}
\end{figure}
También es interesante conocer que archivos genera \programa{MPIDE} a lo largo de la compilación, pero estos archivos son borrados una vez termina la compilación del programa por lo que tendremos que cambiar este comportamiento. Para ello acudiremos al archivo de configuración \orden{preferences.txt} cuya localización varía según el sistema operativo empleado.

\begin{table}[H]
\begin{center}
\begin{tabular}{ll}
  \textbf{Sistema Operativo} & \textbf{Ruta}\\
    \midrule
    \textit{Linux} & /home/[nombre de usuario]/.mpide/preferences.txt\\
    \textit{Mac OSX} & /Users/[nombre de usuario]/Library/mpide/preferences.txt\\
    \textit{Windows} & C:\textbackslash Archivos de Programa\textbackslash \programa{MPIDE}\textbackslash hardware\textbackslash pic32\textbackslash cores\textbackslash pic32\\
  \end{tabular}
\end{center}
\caption{Ruta del archivo \orden{preferences.txt}}
\label{tab:preferences_path}
\end{table}

El archivo \orden{preferences.txt} contiene toda la configuración de MPIDE a excepción de la configuración del compilador, pero nosotros estamos interesados en la línea 75:
\begin{lstlisting}
preproc.save_build_files=false
\end{lstlisting}

Cambiando el valor a \orden{true}, \programa{MPIDE} guardará los archivos temporales de la compilación.

Para ver cómo funciona el proceso de compilación en \programa{MPIDE} usaremos el sketch Blink (\ref{code:blink}).

Para poder observar las acciones que lleva a cabo \programa{MPIDE} durante la compilación del programa podemos mantener apretada la tecla \orden{Mayus} mientras pulsamos el botón de compilar. De esta forma \programa{MPIDE} nos mostrará en el terminal todas las órdenes que ejecute.

\figura{mpide_compilado.jpg}{scale=0.6}{MPIDE después de compilar}{mpide_compilado}{H}

El proceso completo de compilación (lo que se muestra en el terminal) está en el Apéndice \ref{chap:apendice1}.

\programa{MPIDE} comienza copiando nuestro sketch y las bibliotecas que hayamos incluido a una carpeta temporal en la que se realizará el proceso de compilación y ensamblado. Antes de comenzar la compilación, se cambia la extensión del sketch de `.pde'~\footnote{En las últimas versiones de Arduino sería `.ino'.} a `.cpp'. Este archivo se escanea en busca de funciones y las que se encuentren (en \programa{MPIDE} se pueden definir funciones sin declararlas) son declaradas al inicio del archivo de forma automática, incluyendo \orden{setup()} y \orden{loop()} a pesar de estar ya declaradas en el archivo \orden{main.cpp}, junto con \verb|#include<WProgram.h>|. Esta declaración automática de funciones puede ocasionar errores durante la compilación si usamos una función que reciba un parámetro cuyo tipo sea uno creado con una declaración \verb|typedef| al comienzo del archivo, ya que esta función se declarará antes que el parámetro y ocasionará un error de compilación.

Utilizando \orden{pic32-g++} se compila el sketch (con extensión `.cpp') a un archivo objeto `.o'. A continuación compila y, con \orden{pic32-ar}, empaqueta en el archivo \orden{core.a} la biblioteca `Core', es decir, los archivos que se encuentran en la subcarpeta \verb|hardware/pic32/cores| en el direcotorio de instalación de \programa{MPIDE}; de esta forma se facilita su manejo más adelante al ser muchos archivos. Si se han utilizado bibliotecas de terceros se compilan. A continuación se enlazan todos los programas objeto produciendo un archivo ejecutable con extensión `.elf'. Para realizar el enlazado se pasa a la orden, como parámetro, dos scripts de enlazado: uno, común a todas las placas de la misma familia (\orden{ChipKIT-application-common}); y otro, que depende de la placa microcontroladora a la que vaya destinado; en el caso de ChipKIT Max32 es \orden{ChipKIT-application-32MX795F512.ld}.


\programa{MPIDE} utiliza diferentes parámetros a la hora de la compilación y posterior enlazado, comunes a todos los archivos de código fuente, ya sean de la biblioteca `Core' o el sketch. Veamos cuáles son:

\begin{itemize}
    \item \negrita{-ON}. Nivel de optimización. El valor ``N'' varía entre 0 y 3 para optimizaciones generales. Si su valor es ``s'' optimizamos para reducir el espacio que ocupa el programa. Por defecto, el nivel de optimización que utiliza \programa{MPIDE} es 2.
    \item \negrita{-mno-smart-io}. Esta opción deshabilita el análisis estadístico de las cadenas con formato, que son pasadas a \orden{printf} o \orden{scanf} y a las variaciones `f' y `v' de estas funciones.
    \item \negrita{-w}. Esta opción deshabilita todos los mensajes de advertencia.
    \item \negrita{-fno-exceptions}. Esta opción deshabilita el manejo de excepciones.
    \item \negrita{-ffunction-sections}. Con esta opción cada función se coloca en su propia sección en el archivo de salida.
    \item \negrita{-fdata-sections}.Con esta opción cada dato se coloca en su propia sección en el archivo de salida.
    \item \negrita{-g}. Produce información para la depuración.
    \item \negrita{-mdebugger}. Esta opción define el símbolo `\_DEBUGGER', lo que reservará espacio en una sección del archivo de salida (.DBG\_EXCPT) para los vectores de excepción de depuración.
    \item \negrita{-Wcast-align}. Está opción hace que el compilador lance una advertencia cuando a un puntero se le ha hecho un cast, es decir, si cambia el tipo de dato al que estaba apuntando a uno que requiera un tamaño de alineamiento mayor. Por ejemplo, advierte si \orden{char *} se convierte en \orden{int *} en máquinas donde solo se puede acceder a datos de tipo \orden{int} cada dos o cuatro palabras.
    \item \negrita{-fno-short-double}. Esta opción hace que el tipo de variable \orden{double} sea equivalente a \orden{long double} en vez de a \orden{float}, que es la opción por defecto.
    \item \negrita{-mprocessor=?}. Esta opción indica al compilador cuál es el procesador objetivo. En nuestro caso particular se trata de ``32MX795F512L''.
    \item Definiciones de macros para el preprocesador.
    \begin{itemize}
        \item \negrita{-DF\_CPU=?}. Este macro define la frecuencia a la que funciona el procesador. En este caso ``80000000L''.
        \item \negrita{-DARDUINO}. Definimos el macro ``ARDUINO'' con valor 1.
        \item \negrita{-D\_BOARD\_MEGA\_}.Definimos el macro ``\_BOARD\_MEGA\_'' con valor 1. Indica que estamos usando una placa con el formato de un Arduino Mega.
        \item \negrita{-DMPIDEVER=?}. Definimos el valor de ``MPIDEVER'', que es ``0x01000305''.
        \item \negrita{-DMPIDE=?}. Definimos la versión de \programa{MPIDE} que hemos usado. En nuestro caso es la versión 23.
    \end{itemize}
    \item Parámetros de enlazado:
        \begin{itemize}
            \item \negrita{-Os}. Optimizamos para espacio.
            \item \negrita{-Wl,--gc-sections}. Usando ``-Wl'' pasamos opciones al enlazador, separadas por comas. En este caso pasamos la opción ``--gc-sections'' que sirve para eliminar todo el código y datos que no vayan a ser usados por el programa final y que, por lo tanto, no es necesario que se encuentren en él. De esta forma se reduce el tamaño del programa final.
            \item \negrita{-mdebugger}. Misma opción que antes.
            \item \negrita{-mprocessor=?}. Misma opción que antes.
            \item \negrita{-lm}. Enlaza la biblioteca estándar \programa{math} que nos proporciona funciones matemáticas\protect\footnote{http://en.wikipedia.org/wiki/C\_mathematical\_functions}
            \item \negrita{-T}. Con esta opción podemos especificar un script de enlazado. Se usa dos veces: una, para el script \orden{ChipKIT-application-COMMON.ld};\\  y otra para \orden{ChipKIT-application-32MX795F512.ld}.
        \end{itemize}
\end{itemize}

Una vez el programa está compilado y enlazado~\protect\footnote{Suponemos que el nombre del archivo ejecutable es sketch.elf (como ejemplo).} es necesario generar el archivo ejecutable con extensión `.hex' que cargaremos en el microcontrolador. Esto lo consigue \programa{MPIDE} usando los programas \programa{pic32-objcopy} y \programa{pic32-bin2hex}.
\begin{lstlisting}[breaklines=true]
pic32-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 sketch.elf sketch.eep
pic32-bin2hex -a sketch.elf
\end{lstlisting}

\begin{itemize}
  \item \negrita{-O ihex} Crea un archivo con formato hexadecimal.
  \item \negrita{-j .eeprom} Solo copia la sección especificada en la salida, en este caso, la sección .eeprom.
  \item \negrita{--set-section-flags=.eeprom=alloc,load} Establece las propiedades de una sección.
  \item \negrita{--no-change-warnings} Avisa si la sección no existe.
  \item \negrita{--change-section-lma .eeprom=0} Cambia el LMA (Load Memory Address) de la sección.
\end{itemize}

El resultado de ejecutar estas dos órdenes es el archivo \orden{sketch.hex}, que ya podrá ser cargado al microcontrolador.
Para este último paso será necesario usar el programa \programa{avrdude}, bien el que viene incluido con \programa{MPIDE} o el que tengamos instalado en nuestro sistema.
\begin{lstlisting}[breaklines=true]
avrdude -C[Directorio MPIDE]/hardware/tools/avrdude.conf -c stk500v2 -p pic32 -P /dev/ttyUSB0 -b 115200 -v
\end{lstlisting}

\begin{itemize}
  \item \negrita{-C[Directorio MPIDE]/hardware/tools/avrdude.conf} Carga la configuración personalizada de \programa{avrdude}.
  \item \negrita{-c stk500v2} Indica el modelo de progamador.
  \item \negrita{-p pic32} Especifica el modelo de microcontrolador.
  \item \negrita{-P /dev/ttyUSB0} El puerto serie en el que se encuentra conectado el microcontrolador.
  \item \negrita{-b 115200} La velocidad de transmisión en bps del puerto serie.
  \item \negrita{-v} Muestra más información de lo que está sucediendo.
\end{itemize}

\section{Alternativa a \programa{MPIDE}}

Ya hemos visto cómo el IDE genera y carga el sketch. El problema de este método es que no es posible modificar el proceso de una manera sencilla para adaptarlo a un programa en particular. Es posible ejecutar cada uno de las órdenes en un terminal y obtener el mismo resultado que con \programa{MPIDE} pero, aunque esto nos permitiría modificar cada parte del proceso, también lo haría largo y tedioso. Por suerte, hay un programa que nos permite automatizar todo el proceso, manteniendo la posibilidad de modificarlo dependiendo de las necesidades de cada proyecto. Se trata de \programa{GNU make}, un programa muy polivalente que nos permite automatizar multitud de tareas~\footnote{De hecho, con la ayuda de \programa{make} se genera esta memoria en formato PDF a partir de archivos escritos en \LaTeX.}.

De esta forma es posible usar el editor de textos que queramos para generar nuestro código (por ejemplo \programa{VIM} o \programa{emacs}), modificar las opciones de compilación, enlazado y carga de una forma rápida y sencilla. Podemos cambiar las opciones de compilación y enlazado en \programa{MPIDE} mediante la modificación de un archivo de configuración del programa (\orden{platforms.txt}); pero estos cambios afectarían a todos los programas compilados con \programa{MPIDE} y es necesario reiniciar el programa para que tengan efecto.

Para esto he creado una estructura de carpetas a modo de plantilla, para las distintas aplicaciones. Dentro de esta carpeta tenemos diferentes subdirectorios que sirven para almacenar los diferentes tipos de archivos que necesita nuestro programa. En la figura~\ref{plantilla_carpeta} se puede ver la estructura de esta plantilla.

\begin{figure}[H]
\begin{center}
\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
	\node{ChipKIT\_template}
		child { node {bin}}
		child { node {lib}}
		child { node {src}};
\end{tikzpicture}
\end{center}
\caption{Estructura de directorios de la plantilla}
\label{plantilla_carpeta}
\end{figure}

Función de cada carpeta:
\begin{description}
	\item[src] Aquí estrá el código fuente del programa que hayamos creado. Es el lugar en el que se encuentra el archivo de código fuente \orden{sketch.cpp} que contiene las definiciones de las funciones \orden{setup()} y \orden{loop()}. Además, si necesitamos crear nuestras propias bibliotecas (archivos .h junto con su correspondiente archivo .c o .cpp) podemos crearlos tanto en esta carpeta como en \orden{lib}.
	\item[lib] Las bibliotecas de terceros se deben copiar a esta carpeta. Usando el archivo Makefile compilaremos todas las bibliotecas y luego las enlazaremos con nuestro programa y la biblioteca core.
	\item[bin] Una vez el programa es enlazado, el arhivo con extensión `.elf' se guardará en esta carpeta. También se generará ahí el archivo final `.hex' que será el que se cargue en la placa microcontroladora.
\end{description}

Para poder realizar todo el proceso con \programa{make} se necesita un archivo \orden{Makefile} en el que se describe cómo llevarlo acabo. Este archivo se escribe de la siguiente forma:
\begin{listing}[language=make]
objetivo: dependencia_1 dependencia_2 ...
	ordenes
\end{listing}
Esta estructura la podemos repetir para todos los objetivos que sean necesarios. El objetivo es lo que se quiere conseguir a través de las órdenes. Pero para poder ejecutarse es necesario que se cumplan las dependencias (que pueden ser archivos u otros objetivos). En el apéndice~\ref{chap:apendice2} se encuentra el Makefile completo y su funcionamiento.

\programa{make}, siguiendo las instrucciones que se encuentran en el \orden{Makefile}, se encarga de compilar, enlazar y empaquetar la biblioteca core en el archivo \orden{core.a} y luego compila todos los archivos en la carpeta \orden{lib} y la carpeta \orden{src}. Es decir, realiza las mismas operaciones que \programa{MPIDE}, a excepción de la primera de ellas (Buscar funciones en el sketch).

En la plantilla también he incluido un script escrito en Perl que puede ser ejecutado de forma explícita por el usuario y que permite replicar este comportamiento. El script se puede ejecutar sobre el archivo \orden{src/sketch.pde} si existe y genera el fichero en código fuente \orden{src/sketch.cpp} siempre y cuando este último archivo, en caso de existir, esté vacío.

Con el \orden{Makefile} incluido podemos ejecutar diversas acciones dependiendo del objetivo que elijamos. Si se ejecuta \orden{make src/sketch.S} (se puede hacer con cualquier archivo escrito en C o C++ que se encuentre en la carpeta) se compila pero no ensambla ni enlaza el archivo \orden{sketch.cpp}. Del mismo modo, si llamamos a la orden \orden{make src/sketch.o} se compila y ensambla \orden{sketch.cpp}. Por otro lado, \orden{make link} compilará, ensamblará y enlazará el programa guardando el resultado en \orden{bin/main.elf}. Este último es el objetivo por defecto, por lo que si ejecutamos \orden{make} sin ningún argumento, el resultado será el mismo.

Una vez enlazado podemos usar la orden \orden{make load} para cargar el programa en la placa conectada al puerto USB\@. Con esta orden se ejecuta \orden{avrdude} con los mismos parámetros que si fuese llamado a través de \programa{MPIDE}.

En el \orden{Makefile} ya hay dos puertos serie predefinidos según la plataforma: uno para GNU Linux y otro para Mac OS\@. Son los dos puertos en los que podremos encontrar el microntrolador por defecto. Solo hace falta modificar una variable para cambiar el puerto al que está conectada la placa en caso de que sea necesario.
