% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

\section{Hardware}
En esta sección se describirán los dispositivos que van a ser utilizados para la realización del proyecto.

\subsection{ChipKIT Max32}
El microcontrolador elegido para el proyecto es un ChipKIT Max32. Es el modelo más avanzado de la familia Chipkit, que se compone además del Uno32, uC32 y DP32.

\figura{chipKIT-Max32.jpg}{scale=0.6}{Chipkit Max32}{max32}{H}

En el centro del Max32 encontramos como microcontrolador un Microchip PIC32MX795F12L que funciona a 80MHz y con el que disponemos de 512KB de memoria flash y 128KB de memoria RAM. El Max32 tiene 83 puertos de entrada/salida además de otros dispositivos como UART, SPI e I2C. Dieciséis de los 83 puertos puede ser usados como entradas analógicas o como entradas/salidas digitales. A diferencia de su equivalente Arduino (Mega), el ChipKIT Max32 también tiene integrado en el chip 10/100 Ethernet, un controlador USB 2.0 y dos controladores CAN, aunque para hacer uso de estos dispositivos necesitaremos el ChipKIT Network Shield.\\

Este dispositivo, al igual que el resto de microcontroladores de la familia ChipKIT, funciona con un voltaje lógico de 3.3V frente a los microcontroladores Arduino como el Uno o el Mega. Es importante tener este dato en cuenta a la hora de usar shields o dispositivos pensados para placas Arduino.\\

Podemos encontrar más información además de esquemáticos y manuales en la página de información del ChipKIT Max32\cite{website:max32}.\\

Características del ChipKIT Max32:
\begin{itemize}
	\item Procesador Microchip PIC32MX795F512L
		\begin{itemize}
			\item 80MHz 32-bit MIPS
			\item 512KB FLash, 128KB RAM
			\item Controlador USB 2.0 OTG
			\item 10/100 Ethernet MAC
			\item Dos controladores CAN
		\end{itemize}
	\item Proporciona memoria adicional (con respecto al Uno32) y periféricos de comunicación avanzados
	\item Compatible con gran parte del código existente de ejemplo para Arduino, así como con materiales de referencia y otros recursos.
	\item Puede ser programado usando Microchip MPLAB, mediante un programador gracias a su interfaz JTAG.
	\item Mismo tamaño y formato que el Arduino Mega
	\item 83 pines de entrada/salida
	\item LED de usuario (Pin 13)
	\item Se conecta a un PC usando un cable USB A -> mini B
\end{itemize}

\subsubsection{Chipkit PGM}
Para la depuración de los programas con MPLAB usaremos el programador chipKIT PGM\cite{website:pgm}, con el que podremos usar el puerto JTAG del Max32. Este programador está diseñado para ser usado exclusivamente con la familia de dispositivos chipKIT, a diferencia de picKIT3\cite{website:pickit} que puede ser usado con todos los microcontroladores de Microchip.

\figura{chipKIT-PGM.png}{scale=0.3}{ChipKIT PGM}{pgm}{H}

\newpage

\subsection{ChipKIT Network Shield}

El ChipKIT Network Shield es, como su nombre indica, un shield para el ChipKIT Max32. Cabe destacar que este shield no sirve para el ChipKIT Uno32 puesto que este microcontrolador no dispone de las características de las que hace uso este shield, como Ethernet y host USB.Se coloca encima del microcontrolador tal y como lo hace cualquier shield de Arduino.

\figura{chipKIT-NetworkShield.jpg}{scale=0.5}{Chipkit Network Shield}{networkshield}{H}

Este shield nos proporciona las conexiones necesarias para poder hacer uso del controlador Ethernet y USB que lleva el Max32 integrado y a los buses CAN. Además de esto también tiene integrado un oscilador de 32.768 KHz que nos permite hacer uso del RTC que también tiene integrado el Max32 y una memoria EEPROM de 256Kb a la que podemos acceder mediante I2C. En la página web del Network Shield\cite{website:network_shield} podemos encontrar las bibliotecas que nos sirven para hacer uso de sus características, en el entorno ChipKIT.\\

Características del ChipKIT Network Shield:
\begin{itemize}
	\item Puede ser usado con el Max32
	\item SMSC LAN8720 10/100 Ethernet PHY
	\item Conector RJ45
	\item Dispositivo USB y conectores Host
	\item Dos transceptores CAN MCP2551
	\item Dos conectores de 12 pines para los buses CAN
	\item Dos conectores para cadena margarita (daisy chain) I2C
	\item EEPROM de 256Kbits con interfaz I2C
	\item Oscilador a 32.768 KHz
\end{itemize}

\newpage


\subsection{ChipKIT Basic I/O Shield}
El otro shield que usaremos será el ChipKIT Basic I/O Shield que nos servirá para interactuar físicamente con el microcontrolador ya que este shield nos proporciona diferentes métodos de entrada y salida de información.

\figura{chipKIT-BasicIOShield.jpg}{scale=0.5}{ChipKIT Basic I/O Shield}{ioshield}{H}

El ChipKIT Basic I/O shield dispone de los siguientes dispositivos:
\begin{itemize}
	\item EEPROM de 256Kbits con interfaz I2C
	\item Pantalla OLED de 128x32 píxeles
	\item Sensor de temperatura con interfaz I2C
	\item Conector para cadena margarita (daisy chain) I2C
	\item Cuatro drivers FET de colector abierto
	\item Potenciometro analógico
	\item Cuatro pulsadores y cuatro interuptores
	\item Ocho LEDs
\end{itemize}

Este shield está inicialmente pensado para ser usado en un chipKIT Uno32, pero podemos conectarlo al Max32 sin ningún problema ya que comparten el mismo esquema de pines (aunque el Max32 tiene 83 pines frente a los 42 del Uno32). También es posible conectarlo al Network Shield y este a su vez al Max32, teniendo en cuenta la posibilidad de que algunas funciones en los dos shields puedan compartir pines.\\

Igual que el Network Shield, el Basic I/O Shield también dispone de una página web\cite{website:io_shield} en la que podemos encontrar su manual, esquemáticos y las librerías necesarias para usarlas en el entorno ChipKIT.

\newpage

\section{Software} A lo largo del proyecto utilizaremos dos entornos de
desarrollo integrado: \programa{MPIDE} y \programa{MPLAB X}.
\subsection{\programa{MPIDE}} \programa{MPIDE}\cite{website:mpide} es el IDE
creado por Digilent para el entorno ChipKIT. Su diseño es idéntico al IDE de
Arduino, variando solamente el color y el compilador usado.
\figura{mpide.jpg}{scale=0.6}{\programa{MPIDE}}{mpide}{H} \programa{MPIDE} es
un entorno de desarrollo sencillo y con unas características muy básicas y
limitadas. Con él podremos escribir nuestro programa, compilarlo y cargarlo en
nuestro microcontrolador sin necesidad de ninguna otra aplicación, siempre y
cuando hayamos seleccionado el modelo adecuado y el puerto serie en las
opciones del programa. \\ Al igual que el entorno de Arduino, no es posible
depurar programas, para eso usaremos \programa{MPLAB X}. También dispone de un monitor
para el puerto serie, con el que podemos leer lo que el microcontrolador envía
a través de este puerto y enviar información al microcontrolador.
\subsection{\programa{MPLAB X}} \programa{MPLAB X}\cite{website:mplab} es la última versión del
entorno de desarrollo integrado de Microchip. A diferencia de
\programa{MPIDE}, este programa es un IDE completo, basado en Netbeans. Está
pensado para ser utilizado con toda su gama de microcontroladores y, con la
ayuda de un depurador/programador como el chipKIT PGM podremos depurar
nuestros programas. Si queremos, también podemos usar los productos chipKIT
como cualquier otro microcontrolador de Microchip, escribiendo los programas
en este IDE y compilándolos con el compilador que tiene Microchip disponible
en su página web, C32\cite{website:c32}. \figura{mplab.jpg}{scale=0.35}{MPLAB
X Depurando}{mplab}{H}

Como se aprecia en la Figura \ref{mplab} \programa{MPLAB X} nos ofrece mucha más información y posibilidades que \programa{MPIDE}. En esta figura vemos a \programa{MPLAB X} en mitad de la depuración del programa Blink, que fue compilado usando \programa{MPIDE}.\\
Con este entorno de desarrollo veremos más adelante los diferentes efectos de que los distintos niveles de optimización tienen en nuestro programa y podremos usarla para hacer profiling.


\section{Estructura de un programa Arduino}
En cualquier programa para Chipkit o Arduino podemos encontrar tres grupos principales de código fuente.
\subsection{Core}
Para empezar, tenemos los archivos que formarán parte de la biblioteca ``Core'' a la hora de la compilación. Estos archivos vienen incluidos con \programa{MPIDE} y los podemos encontrar en el directorio en el que tengamos instalado \programa{MPIDE}, en la subcarpeta:\\
\comando{hardware/pic32/cores/pic32}
\begin{table}[H]
\begin{center}
\begin{tabular}{| c || c |}
    \hline
    Sistema Operativo & Ruta\\
    \hline
    \hline
    Linux & /opt/mpide/hardware/pic32/cores/pic32\\
    \hline
    Mac OSX & /Applications/Mpide.app/Contents/Resources/Java/hardware/pic32/cores/pic32\\
    \hline
    Windows & C:\textbackslash Archivos de Programa\textbackslash \programa{MPIDE}\textbackslash hardware\textbackslash pic32\textbackslash cores\textbackslash pic32\\
    \hline
  \end{tabular}
\end{center}
\caption{Ruta de la biblioteca Core}
\label{tab:core_path}
\end{table}
En esta biblioteca tenemos ya definidas las funciones que necesitamos para interactuar con los dispositivos que están integrados en la placa (en nuestro caso ChipKIT Max32). Para más información acerca de estas funciones y como utilizarlas podemos acudir a la página de referencia de Arduino\cite{website:arduino_funcs}.
Además, en esta biblioteca está ya definida la función main de nuestro programa y tiene el siguiente aspecto:
\lstset{language=C++}
\begin{lstlisting}[caption=main.cpp]
#define OPT_SYSTEM_INTERNAL
#include <System_Defs.h>

#if (ARDUINO >= 100)
	#include <Arduino.h>
#else
	#include <WProgram.h>
#endif

int main(void)
{
	init();
	setup();
	
	while(1)
	{
		_scheduleTask();
		loop();
	}
	return 0;
}
\end{lstlisting}

\subsection{Sketch}
Los programas que escribimos usando \programa{MPIDE} (o el IDE de Arduino) se llaman sketches. En realidad, no escribimos un programa completo porque, como acabamos de ver, el programa en sí ya está escrito en la biblioteca Core. Nuestro objetivo es implementar dos funciones: \comando{setup()} y \comando{loop()}, que ya están declaradas en el archivo de cabecera wiring.h.\\
\begin{lstlisting}[caption=Sección de wiring.h]
void setup(void);
void loop(void);
\end{lstlisting}

Como se puede apreciar en la declaración de ambas funciones, estas no esperan ni devuelven ningún valor.\\
\lstinputlisting[language=C++, caption=Sketch básico ("BareMinimum.pde")]{codigo_fuente/BareMinimum.pde}
En \comando{setup()} colocaremos el código para la inicialización de nuestro programa. Es el lugar donde podemos configurar el puerto serie, por ejemplo, o definir como se comportarán los pines (entrada o salida), entre otras cosas. En definitiva, es el lugar donde debemos colocar el código que queramos que se ejecuta una vez al inicio del programa y que no vuelva a ejecutarse más.\\
En \comando{loop()} pondremos el código que se ejecutara de forma cíclica indefinidamente ya que, como podemos observar en main.cpp, la función \comando{loop()} se encuentra dentro de un bucle infinito.\\

Veamos como ejemplo el sketch Blink:
\lstinputlisting[language=C++, caption=Blink.pde, label=code:blink]{codigo_fuente/Blink.pde}

En este sketch utilizamos las funciones de Arduino pinMode,digitalWrite y delay. En la función \comando{setup()} inicializamos el puerto al que está conectado el LED como una salida\footnote{PIN\_LED1 está definido en el archivo de cabecera Board\_Defs.h que depende del modelo de microcontrolador que estemos usando}, mientras que en \comando{loop()} encendemos y apagamos el LED con retardos de un segundo.

\subsection{Bibliotecas de terceros}
A parte del código de Arduino y del que creemos nosotros, también es posible añadir bibliotecas de terceros. Gracias a la amplia comunidad detrás de Arduino podemos encontrar cientos de ellas. A la hora de usar una biblioteca de Arduino en ChipKIT tendremos que asegurarnos de que no haga uso de funciones específicas de los procesadores Atmel que encontramos en las placas Arduino, ya que no funcionarán en PIC32.\\
Cuando trabajamos con \programa{MPIDE} podemos encontrar las bibliotecas en dos sitios diferentes. \programa{MPIDE} tiene incluidas varias bibliotecas que podemos encontrar en el directorio ``libraries'' dentro de la carpeta en la que esté instalado \programa{MPIDE}. A parte de estas bibliotecas podemos instalar bibliotecas que descarguemos de Internet o que creemos nosotros dentro de la carpeta ``libraries'' en el directorio ``sketchbook''\footnote{La carpeta ``libraries'' no existe. Es neciesario crearla dentro del directorio ``sketchbook''.} que \programa{MPIDE} habrá creado la primera vez que lo ejecutemos.\\
Con las bibliotecas instaladas en uno de los dos directorios podremos añadirlas a nuestro programa de dos formas diferentes. Podemos añadirlas usando el menú de MPIDE, pudiéndolas encontrar en \comando{Sketch > Import Library}. También es posible usar la directiva \comando{\#include <[Archivo De Cabezera].h>} como haríamos en cualquier programa escrito en C/C++. \programa{MPIDE} se encargará de compilar las bibliotecas y enlazarlas con nuestro programa.

\section{Proceso de compilación de \programa{MPIDE}}
En este apartado trataremos de describir el proceso que sigue \programa{MPIDE} para la compilación y posterior carga en el microcontrolador del programa creado en \programa{MPIDE}. Nuestro objetivo será saber que programas y opciones de compilación usa el IDE de ChipKIT.\\
También es interesante conocer que archivos genera \programa{MPIDE} a lo largo de la compilación, pero estos archivos son borrados una vez termina la compilación del programa por lo que tendremos que cambiar este comportamiento. Para ello acudiremos al archivo de configuración \comando{preferences.txt} cuya localización varía según el sistema operativo empleado.

\begin{table}[H]
\begin{center}
\begin{tabular}{| c || c |}
    \hline
    Sistema Operativo & Ruta\\
    \hline
    \hline
    Linux & /opt/mpide/hardware/pic32/cores/pic32\\
    \hline
    Mac OSX & /Users/[nombre de usuario]/Library/mpide/preferences.txt\\
    \hline
    Windows & C:\textbackslash Archivos de Programa\textbackslash \programa{MPIDE}\textbackslash hardware\textbackslash pic32\textbackslash cores\textbackslash pic32\\
    \hline
  \end{tabular}
\end{center}
\caption{Ruta del archivo \comando{preferences.txt}}
\label{tab:preferences_path}
\end{table}

El archivo \comando{preferences.txt} contiene toda la configuración de MPIDE a excepción de la configuración del compilador, pero nosotros estamos interesados en la línea 75:
\begin{lstlisting}
preproc.save_build_files=false
\end{lstlisting}

Cambiando el valor a \comando{true} \programa{MPIDE} guardará los archivos temporales de la compilación.\\
Para ver como funciona el proceso de compilación en \programa{MPIDE} usaremos el sketch Blink (\ref{code:blink}).\\
Para ver que se ejecuta cuando compilamos nuestro programa en \programa{MPIDE} podemos mantaner pulsado la tecla \comando{Mayus} mientras pulsamos el botón de compilar. De esta forma \programa{MPIDE} nos mostrará todos los comandos que ejecute, en el terminal.

\figura{mpide_compilado.jpg}{scale=0.6}{MPIDE después de compilar}{mpide_compilado}{H}
