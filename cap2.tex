% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 


En este capitulo analizaré las características del Arduino Mega 2560\footnote{En la introducción menciono el Arduino Mega ADK, pero la única diferencia entre ambos es que este último puede hacer de Host USB para poder conectar un teléfono móvil Android.} y del ChipKIT MAX32, que es el equivalente en chipKIT, tanto en formato y dimensiones como en precio.

Cuando se usa el término Arduino normalmente se hace refierencia a la plataforma en general. Con este nombre también se conoce a las placas microcontroladoras oficiales de la plataforma, que se fabrican en Italia.

La familia de placas Arduino se compone de multitud de placas microcontroladoras con características diferentes pero hay dos que se pueden destacar sobre las demas debido a que son las más utilizadas.  Estas dos placas son la Arduino Uno y Arduino Mega 2560. La placa Arduino Uno es la más básica y económica, con un formato reducido, mientras que la segunda tiene un precio superior y mejores características.

\section{Arduino Mega 2560}
La placa Arduino Mega 2560 es el modelo avanzado de la familia Arduino, aspecto que se aprecia en las características y en el precio, cuando lo comparamos con su hermana menor: la placa Arduino Uno.

\figura{ArduinoMega2560_R3_Front.jpg}{scale=0.1}{Arduino Mega 2560}{mega2560}{H}

Arduino Mega 2560 es una placa microcontroladora basada en el chip ATmega2560 que fue introducida en el mercado durante el último trimestre de 2010.  
Es una actualización del Arduino Mega, basada en el chip ATmega1280.\@ Dispone de 54 pines de entrada/salida (14 de estos pines pueden ser usado como salidas PWM), 16 entradas analógicas, 4 UARTs (puertos serie que se pueden usar para conectar la placa al ordenador, a periféricos o a otra placa microcontroladora), un oscilador de cristal de 16 MHz, un conector de alimentación, un botón de reinicio y un conector ICSP.\@

\begin{table}
\begin{center}
\begin{tabular}{| l | c |}
\hline
Microcontrolador 						& ATmega2560 \\
Voltaje									& 5~V \\
Voltaje de alimentación (recomendado) 	& 7-12~V \\
Voltaje de alimentación (límites) 		& 6-20~V \\
Pines Entrada/Salida digitales			& 54 (15 salidas PWM) \\
Pines de entrada analógicos				& 16 \\
Corriente por cada pin entrada/salida 	& 40~mA \\
Corriente en el pin de 3,3~V				& 50~mA \\
Memoria Flash 							& 256~kB (8 kB usados por el bootloader) \\
SRAM									& 8~kB \\
EEPROM									& 4~kB \\
Frecuencia del reloj					& 16~MHz \\
\hline
\end{tabular}
\end{center}
\caption{Especificaciones de Arduino Mega 2560.}
\label{tab:mega2560_specs}
\end{table}
% Cosas que mencionar
% Cantidad de memoria
% Voltaje (5V)
% JTAG Pero en las lineas de los ADC
% ADC (pag 275 datasheet) 'solo' 15ksps
Una de las carácterísticas de las placas Arduino es su voltaje de funcionamiento de 5~V. Este voltaje se puede obtener desde la conexión USB al PC ya que la línea de alimentación de este es también de 5~V, o se puede usar una fuente de alimentación externa con un voltaje de entre 7~V y 12~V.

El Arduino Mega 2560 dispone de 256~kB de memoria flash.\footnote{En los microcontroladores de Atmel esto viene indicado en el propio nombre, en este caso 2560 hace referencia a sus 256~kB de memoria Flash.} Esta cantidad es suficiente para la mayoría de proyectos a los que estaría destinada esta placa. Por otro lado su memoria SRAM es de tan solo 8~kB, lo que puede ser el factor limitante en algunos proyectos.

Esta placa tiene también la posibilidad de depurar sus programas a través del puerto JTAG del Atmega 2560. En lugar de tener una conexión dedicada, los pines del puerto JTAG están situados en los mismos dedicados a las entradas analógicas, lo que dificulta la depuración de código que haga uso de estas entradas.

Otra característica que se puede destacar de este Arduino son los convertidores analógico-digital que tiene incorporados el microcontrolador. Hay 2 ADCs en los que podemos encontrar 8 pines de entrada multiplexados en cada uno. Su resolución es de 10~bits y su máxima frecuencia de muestreo (con toda la resolución) es de 15~ksps. Como veremos después, este valor es bajo y puede resultar determinante dependiendo del proyecto en que se vaya a usar. Es posible obtener una mayor frecuencia de muestreo, pero a cambio de reducir la resolución.

La placa Mega 2560 recibe su nombre del microcontrolador que lleva instalado, un Atmel Atmega2560. Todos los periféricos que están incluidos en la placa los podemos encontrar integrados en este chip, de forma que el resto de componentes electrónicos son los dedicados a las entradas y salidas o a la alimentación de la propia placa, con la excepción del chip Atmega 16u2 que se encarga de gestionar la conexión a través del puerto USB con el ordenador.

El núcleo del Atmega 2560 está basado en una arquitectura AVR de 8~bits. AVR utiliza una arquitectura Harvard, de forma que la CPU dispone de buses independientes para datos y programa. El ciclo de instrucción está segmentado en dos partes: mientras una instrucción es ejecutada, la siguiente está siendo obtenida desde la memoria Flash. De esta forma, se ejecuta una instrucción por ciclo, siempre y cuando no haya dependencias entre las instrucciones.
% Cosas para mencionar
% Frecuencia de reloj
% 8 Bits
% Arquitectura AVR
% Pipeline de 2 fases
% NO MDU
% NO FPU
% 32 Registros
% No MMU
\figura{atmel2560_diagrama.jpg}{scale=0.7}{Diagrama de la arquitectura AVR}{atmel2560}{H}

Como se puede ver en la figura~\ref{atmel2560}, el núncleo AVR consta de 32 registros de 8 bits de propósito general en los que se almacenan los datos que serán procesados en la unidad aritmético-lógica (ALU). Esta unidad soporta operaciones aritméticas y lógicas entre registros o entre un registro y una constante guardando el resultado de nuevo en los registros, en un solo ciclo. Estas operaciones son llevadas a cabo sobre operandos de 8 bits (el tamaño de cada registro) por lo que cualquier operación sobre números enteros de 32~bits (operación más habitual en programas) requerirá más ciclos. Las operaciones aritméticas que puede realizar esta ALU son suma, resta y multiplicación de números de coma fija; sin embargo no dispone de una instrucción de división, por lo que es necesario usar una que funcione mediante software. Tampoco tiene una unidad de coma flotante (FPU) por lo que estamos limitados a números en coma fija o a la emulación de coma flotante a través de bibliotecas, que es lo que sucede cuando usamos variables de tipo `float' durante el desarrollo de una aplicación para Arduino.

Este microcontrolador incluye varios perífericos. Posee un total de 6 temporizadores/contadores, dos de ellos de 8~bits y los otros 4 de 16~bits de resolución. También tiene un RTC (Real Time Counter) que permite llevar la cuenta del tiempo real con un oscilador externo conectado al pin TOSC1. Si observamos el esquemático del Arduino Mega 2560 vemos que ese pin no está conectado a nada, es decir, no contiene un oscilador, y tampoco está asociado con ninguno de los conectores disponibles en la placa, por lo que no podremos usar esta funcionalidad. Otros periféricos que encontramos en este chip son 2 interfaces serie: SPI y 2-wire, y un temporizador programable `watchdog' que requiere también un oscilador externo, por lo que tampoco podremos hacer uso de esta característica con la placa Arduino. Por último, también tiene la capacidad de generar interrupciones cuando algún pin cambia su valor, por lo que no será necesario estar activamente esperando durante la ejecución del programa.

\section{ChipKIT Max32}
La placa microcontroladora elegida para el trabajo es una ChipKIT Max32 de DigilentINC.\@ Es el modelo más avanzado de la familia ChipKIT, que se compone además del Uno32, uC32 y DP32.

\figura{chipKIT-Max32.jpg}{scale=0.6}{Chipkit Max32}{max32}{H}

En el centro del Max32 encontramos como microcontrolador un Microchip PIC32MX795F12L que funciona a 80~MHz y con el que disponemos de 512~KB de memoria flash y 128~KB de memoria RAM.\@ Sin embargo, a diferencia del Arduino Mega 2560, no incluye memoria EEPROM en el chip por lo que no podemos almacenar datos de forma no volátil. 

El Max32 tiene 83 puertos de entrada/salida además de otros dispositivos como UART, SPI e I2C. Dieciséis de los 83 puertos pueden ser usados como entradas analógicas o como entradas/salidas digitales. A diferencia de su equivalente Arduino (Mega), el ChipKIT Max32 también tiene integrado en su MCU 1 módulo 10/100 Ethernet, 1 controlador USB 2.0 y 2 controladores CAN, aunque para hacer uso de estos dispositivos necesitaremos el ChipKIT Network Shield ya que es en esta placa donde están los conectores. 

Al igual que el Arduino Mega 2560, el microcontrolador de esta placa también tiene un RTC (Real Time Clock) que nos permita mantener la hora actual siempre que esté conectado a alguna fuente de alimentación. Para poder usar esta característica es necesario conectar un cristal de cuarzo que funcione a 32~768~kHz al pin correspondiente. En este caso, a diferencia del Arduino Mega 2560, el pin del oscilador se encuentra mapeado a uno de los pines de entrada/salida en los conectores de la placa por lo que podremos hacer uso de este periférico.\footnote{En el ChipKIT Uno32 podemos encontrar dos agujeros en la placa donde es posible soldar directamente un cristal para el RTC.}

\begin{table}[H]
\begin{center}
\begin{tabular}{| l | c |}
\hline
Microcontrolador 						& Microchip PIC32MX795F512L \\
Voltaje									& 3,3~V \\
Voltaje de alimentación (recomendado) 	& 7-15~V \\
Voltaje de alimentación (límites) 		& 6-20~V \\
Pines Entrada/Salida digitales			& 83 (14 salidas PWM) \\
Pines de entrada analógicos				& 16 \\
Corriente por cada pin entrada/salida 	& 18 mA \\
Corriente en el pin de 3,3~V				& N/A  \\
Memoria Flash 							& 512~kB (8 kB usados por el bootloader) \\
SRAM									& 128~kB \\
EEPROM									& No \\
Frecuencia del reloj					& 80~MHz \\
\hline
\end{tabular}
\end{center}
\caption{Especificaciones de ChipKIT MAX32.}
\label{tab:max32_specs}
\end{table}

Este dispositivo, al igual que el resto de microcontroladores de la familia ChipKIT, funciona con un voltaje lógico de 3,3~V frente a los microcontroladores Arduino como el Uno o el Mega que usan un voltaje de 5~V. Es importante tener este dato en cuenta a la hora de usar shields o dispositivos pensados para placas Arduino ya que están diseñandos para 5~V y es posible que no reciban bien los datos desde el Max32 por no superar en alguna ocasión el umbral de detección lógico, es decir, el voltaje a partir del cual se determina que el bit recibido es un `1'. Por otro lado esta placa puede recibir señales con voltaje de 5~V sin dañarse por lo que no supone ningún peligro conectar shields pensados para placas Arduino.

Podemos encontrar más información, además de esquemáticos y manuales en la página de información del ChipKIT Max32 en la web de Digilent.\cite{website:max32}

El microcontrolador que utiliza la placa Max32, el PIC32MX795F512L, es el modelo más avanzado de la familia PIC32MX de Microchip. Como su nombre indica, se trata de un procesador de 32~bits, frente a los 8 del Atmel. Su arquitectura, aunque también basada en Harvard, es completamente diferente de la del Atmega. Se trata de la arquitectura MIPS, en su versión M4K. Este núcleo consta de 32 registros de propósito general de 32~bits. También cuenta con otro juego de 32 registros (shadow registers) que usa durante interrupciones. De esta forma, cuando se produce alguna interrupción no es necesario guardar los registros principales por lo que la transición de un estado a otro es más rápida.

\figura{m4k_diagram.jpg}{scale=0.7}{Diagrama del Núcleo M4K}{m4kdiagrama}{H}

Como se puede apreciar en la figura~\ref{m4kdiagrama} este chip cuenta con una MDU (unidad de multiplicación y división), un coprocesador y una unidad de administración de memoria (MMU). Ninguno de estas unidades podemos encontrarlas en el chip de Atmel. El MDU nos permite realizar multiplicaciónes entre operandos de 16~bits (o uno de 16 y otro de 32~bits) en un solo ciclo y entre dos operandos de 32~bits en dos o tres ciclos frente al ciclo que tarda la multiplicación de dos operandos de 8 bits en el núcleo AVR.\@ Además, con esta unidad se pueden realizar divisiones mediante hardware sin tener usar bibliotecas (como pasa con el Atmega), y el tiempo de estas operaciones es de 35 ciclos de reloj en el peor de los casos.

El coprocesador es una interfaz de registros que sirve para comunicar información de control y estado entre el programa y la CPU.\@ A través del coprocesador tenemos acceso al `core timer', al control de interrupciones y excepciones, a la configuración de la memoria virtual, al control de los registros `shadow', a la identificación del procesador y al control de depuración.

\figura{m4k_pipeline.jpg}{scale=0.7}{Segmentación (simplificada) en MIPS}{mipspipeline}{H}

MIPS fue desarrollada por John L. Hennessy y su equipo como una arquitectura de tipo RISC de 32~bits. Al igual que AVR, MIPS cuenta con segmentación de instrucciones, pero dividido en 5 etapas mostradas en la figura~\ref{mipspipeline}. Estas etapas son: Instruction Fetch, Execution, Memory Fetch, Align y Writeback. Podemos encontrar una descripción detallada de los procesos que se llevan a cabo en cada una de ellas en el apartado 2.3 del manual de referencia de PIC32MX accesible a través de la página web del PIC32MX795F512L~\cite{website:pic32mx}. Este microcontrolador también incluye mecanismos para evitar las interrupciones en la ejecución de instrucciones por dependencia de datos. Para ello utiliza realimentación de forma que la etapa de ejecución puede obtener operandos directamente desde la etapa `M' o la etapa `A' como se puede ver en la figura~\ref{mipspipeline}. Usando la realimentación se puede enviar los operandos desde una de esas etapas reduciendo posibles ciclos de espera. El incremento en rendimiento en operaciones que involucren a la ALU supone alcanzar una instrucción por ciclo incluso con la presencia de dependencia de registros.

Desde el punto de vista académico, usar este microcontrolador con arquitectura MIPS frente al Atmel y su AVR tiene la ventaja de que MIPS se estudia en la asignatura `Arquitectura de computadores y sistemas operativos I'. Esto ayuda a la hora de desarrollar programas al estar ya familiarizado con el juego de instrucciones y su segmentación de instrucciones, incluyendo los riesgos de control y datos, y cómo se reducen.

\section{Accesorios}
Durante el trabajo utilizaré varios accesorios junto con el ChipKIT MAX32 que me permiten depurar programas, conectar la placa a la red Ethernet y me proporcionan algunos elementos de entrada-salida como LEDs, botones o una pantalla OLED.\@
\subsection{Chipkit PGM}
Para la depuración de los programas con MPLAB usaré el programador chipKIT PGM\cite{website:pgm}, con el que podré usar el puerto JTAG del Max32. Este programador está diseñado por Digilent (Fabricante de las placas ChipKIT) para ser usado con la familia de dispositivos chipKIT. Microchip también dispone de su propio programador, el picKIT3~\cite{website:pickit}, con el que se podría también programar estos microcontroladores. Las principales diferencias entre el ChipKIT PGM y el picKIT es que el primero esta diseñado solamente para ser usado con microcontroladores que funcionen con un volaje de 3.3 V mientras que el programador de Microchip puede ser usado también con dispositivos que funcionen a 5 V. El precio del ChipKIT PGM es inferior al del PicKIT, lo que lo hace la opción adecuada para este trabajo, al ulizar exclusivamente una placa microcontroladora ChipKIT.

\figura{chipKIT-PGM.png}{scale=0.3}{ChipKIT PGM}{pgm}{H}

\subsection{ChipKIT Network Shield}

El ChipKIT Network Shield es, como su nombre indica, un shield para el ChipKIT MAX32.\@ Cabe destacar que este shield no sirve para el ChipKIT Uno32 puesto que el microcontrolador que está montado en ella no dispone de las características de las que hace uso esta placa, como Ethernet y host USB.\@ Se coloca encima del microcontrolador tal y como lo hace cualquier shield de Arduino.

\figura{chipKIT-NetworkShield.jpg}{scale=0.5}{Chipkit Network Shield}{networkshield}{H}

Este shield nos proporciona las conexiones necesarias para poder hacer uso del controlador Ethernet y USB que lleva el Max32 integrado y a los buses CAN.\@ Además de esto también tiene integrado un oscilador de 32~768 KHz que nos permite hacer uso del RTC que también tiene integrado el Max32 y una memoria EEPROM de 256~Kb a la que podemos acceder mediante I2C. En la página web del Network Shield~\cite{website:network_shield} podemos encontrar las bibliotecas que nos sirven para hacer uso de sus características, en el entorno ChipKIT.\@

Características del ChipKIT Network Shield:
\begin{itemize}
	\item Puede ser usado con el Max32
	\item SMSC LAN8720 10/100 Ethernet PHY
	\item Conector RJ45
	\item Dispositivo USB y conectores Host
	\item 2 transceptores CAN MCP2551
	\item 2 conectores de 12 pines para los buses CAN
	\item 2 conectores para cadena margarita (daisy chain) I2C
	\item EEPROM de 256~Kbits con interfaz I2~C
	\item Oscilador a 32~768~KHz
\end{itemize}

\subsection{ChipKIT Basic I/O Shield}
El otro shield que usaré será el ChipKIT Basic I/O Shield que nos servirá para interactuar físicamente con el microcontrolador ya que este shield nos proporciona diferentes métodos de entrada y salida de información.

\figura{chipKIT-BasicIOShield.jpg}{scale=0.5}{ChipKIT Basic I/O Shield}{ioshield}{H}

El ChipKIT Basic I/O shield dispone de los siguientes dispositivos:
\begin{itemize}
	\item EEPROM de 256~Kbits con interfaz I2C
	\item Pantalla OLED de 128$\times$32 píxeles
	\item Sensor de temperatura con interfaz I2C
	\item Conector para cadena margarita (daisy chain) I2C
	\item 4 drivers FET de colector abierto
	\item Potenciometro analógico
	\item 4 pulsadores y cuatro interuptores
	\item 8 LEDs
\end{itemize}

Este shield está inicialmente pensado para ser usado en un chipKIT Uno32, pero podemos conectarlo al Max32 sin ningún problema ya que comparten el mismo esquema de pines (aunque el Max32 tiene 83 pines frente a los 42 del Uno32). También es posible conectarlo al Network Shield y este a su vez al Max32, teniendo en cuenta la posibilidad de que algunas funciones en los dos shields puedan compartir pines.

Igual que el Network Shield, el Basic I/O Shield también dispone de una página web~\cite{website:io_shield} en la que podemos encontrar su manual, esquemáticos y las bibliotecas necesarias para usar en el entorno ChipKIT.\@
