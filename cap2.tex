% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 


%El error más grave de todo este capítulo radica en los tiempos verbales utilizados. A mí no me acaba de gustar la primera persona, aunque lo acepto. 
%Lo que sí que no me gusta es el futuro, aquí queda mejor el pret. perfecto, es decir, no hay que decir "usaré" sino "he usado"
%Tampoco me gusta lo de las placas... creo que sería mejor hablar de productos comerciales
% Y FALTAN REFRENCIAS a los models, sobre todo a MIPS y a MIPS4K

En este capitulo he analizado las características del Arduino Mega y del ChipKIT MAX32, que es el equivalente en chipKIT, tanto en formato y dimensiones como en precio.

\begin{table}[hb]
\begin{center}
\begin{tabular}{lll}
  \textbf{Características}                                & \textbf{Arduino Mega}&\textbf{ChipKIT MAX32}\\
  \toprule
  \textbf{Microcontrolador}                               & ATmega2560          & Microchip PIC32MX795F512L\\
  \textbf{Voltaje}                                        & 5~V                 & 3.3~V\\
  \textbf{Voltaje de alimentación (recomendado)}          & 7-12~V              & 7-15~V\\
  \textbf{Voltaje de alimentación (límites)}              & 6-20~V              & 6-20~V\\
  \textbf{Pines Entrada/Salida digitales}                 & 54 (15 salidas PWM) & 83 (14 salidas PWM)\\
  \textbf{Pines de entrada analógicos}                    & 16                  & 16\\
  \textbf{Corriente máxima por cada pin entrada/salida}   & 40~mA               & 18~mA\\
  \textbf{Corriente máxima en el pin de 3,3~V}            & 50~mA               & N/A\\
  \textbf{Memoria Flash}                                  & 256~kB              & 512~kB\\
  \textbf{SRAM}                                           & 8~kB                & 128~kB\\
  \textbf{EEPROM}                                         & 4~kB                & No tiene\\
  \textbf{Frecuencia del reloj}                           & 16~MHz              & 80~MHz\\
\end{tabular}
\end{center}
\caption{Comparación de características técnicas entre Arduino Mega y ChipKIT MAX32}
\label{tab:comparacion_specs}
\end{table}

Cuando se usa el término Arduino normalmente se hace refierencia a la plataforma en general. Con este nombre también se conoce a las productos oficiales de la plataforma, que se fabrican en Italia, los que se encuentran mencionados en la web oficial de Arduino~\footnote{http://arduino.cc/en/Main/Products}.

La familia de hardware Arduino se compone de multitud de productos comerciales con características diferentes pero hay dos que se pueden destacar sobre las demas debido a que son las más utilizadas.  Estos dos dispositivos son Arduino Uno y Arduino Mega. Arduino Uno es el producto más básico y económico, con un formato reducido, mientras que Arduino Mega tiene un precio superior y mejores características.

%% MUY importante: pon aquí la definición de shield. También sería interesante que destacaras las ventajas que tiene la amplia colección de shield existentes y lo fácil que es su conexión a placas que sean 100% compatibles con Arduino
% Revisa las comillas de pincharlas... no sabía como se hacía exactamente
Tan importantes como las placas que contienen el procesador son las placas de expansión disponibles para Arduino, denominadas \textit{Shields}. Un \textit{Shield} es un circuito impreso que cumple una función determinada, como por ejemplo proporcionar una interfaz ethernet o mediciones de distintos valores ambientales mediante sensores incorporados. Su característica principal con respecto a otros circuitos es que tiene el mismo tamaño que las placas Arduino, con la misma distribución de conectores. Están diseñadas de forma que, una vez conectada, esta queda encima del Arduino y todos los puntos de conexión quedan disponibles en el propio \textit{Shield}. Esta característica hace posible incorporar otro \textit{Shield} encima del anterior siempre y cuando fuesen eléctricamente compatibles, ya que no podrán compartir pines, es decir, dos placas de expansión no pueden usar un mismo pin al mismo tiempo. Estos circuitos son de gran importancia en el ecosistema Arduino ya que debido a la gran cantidad de \textit{Shields} existentes en el mercado, tanto oficiales como de terceros, las posibilidades de la plataforma Arduino son prácticamente ilimitadas.

Estas placas de expansión o \textit{shields} están diseñadas para que su integración con Arduino sea tan sencillo como `pincharlas'  en una placa Arduino y enlazar la biblioteca de funciones correspondiente.

\section{Arduino Mega}
La placa Arduino Mega es el modelo avanzado de la familia Arduino, aspecto que se aprecia en las características y en el precio, cuando lo comparamos con su hermana menor: la placa Arduino Uno.

\figura{ArduinoMega2560_R3_Front.jpg}{scale=0.1}{Arduino Mega}{mega2560}{H}

Arduino Mega es una placa microcontroladora basada en el chip ATmega2560 que fue introducida en el mercado durante el último trimestre de 2010.  
Es una actualización del Arduino Mega, basada en el chip ATmega1280.\@ Dispone de 54 pines de entrada/salida (14 de estos pines pueden ser usado como salidas PWM), 16 entradas analógicas, 4 UARTs (puertos serie que se pueden usar para conectar la placa al ordenador, a periféricos o a otra placa microcontroladora), un oscilador de cristal de 16 MHz, un conector de alimentación, un botón de reinicio y un conector ICSP.\@

Una de las características de las placas Arduino es su voltaje de funcionamiento de 5~V. Este voltaje se puede obtener desde la conexión USB al PC ya que la línea de alimentación de este es también de 5~V, o se puede usar una fuente de alimentación externa con un voltaje de entre 7~V y 12~V. Además, todos los productos Arduino basados microcontroladores Atmel y cuyo voltaje de funcionamiento sea 5~V también disponen de un pin que proporciona 3.3~V. Esto es así porque es posible conectar dispositivos cuyo voltaje de funcionamiento sea de 3.3~V siempre y cuando solamente se lean datos desde este dispositivo, es decir, el chip microcontrolador del Arduino es capaz de leer correctamente niveles lógicos de 3.3V, por lo que si recibe una señal con ese nivel no tiene problemas en detectar un nivel alto. De acuerdo a las especificaciones del chip Atmel, el mínimo voltaje que se detecta como nivel alto en pines de propósito general es 0.6~V por lo que cualquier señal que supere este valor será detectada como un uno lógico. Cabe destacar que, aunque el microcontrolador pueda recibir estos voltajes, no los puede generar. Tan solo puede generar niveles lógicos de 5~V por lo que si se conecta un dispositivo de menor nivel hay que tener esto en cuenta ya que puede ser dañado al recibir un voltaje más alto del recomendado.

El Arduino Mega dispone de 256~kB de memoria flash.\footnote{En los microcontroladores de Atmel esto viene indicado en el propio nombre, en este caso 2560 hace referencia a sus 256~kB de memoria Flash.} Esta cantidad es suficiente para la mayoría de proyectos a los que estaría destinada esta placa. Por otro lado su memoria SRAM es de tan solo 8~kB, lo que puede ser el factor limitante en algunos proyectos.

Esta placa tiene también la posibilidad de depurar sus programas a través del puerto JTAG del Atmega 2560. En lugar de tener una conexión dedicada, los pines del puerto JTAG están situados en los mismos dedicados a las entradas analógicas, lo que dificulta la depuración de código que haga uso de estas entradas.

Otra característica que se puede destacar de este Arduino son los convertidores analógico-digital que tiene incorporados el microcontrolador. Hay 2 ADCs en los que podemos encontrar 8 pines de entrada multiplexados en cada uno. Su resolución es de 10~bits y su máxima frecuencia de muestreo (con toda la resolución) es de 15~ksps. Como veremos después, este valor es bajo y puede resultar determinante dependiendo del proyecto en que se vaya a usar. Es posible obtener una mayor frecuencia de muestreo, pero a cambio de reducir la resolución.

La placa Mega recibe su nombre del microcontrolador que lleva instalado, un Atmel Atmega2560. Todos los periféricos que están incluidos en la placa los podemos encontrar integrados en este chip, de forma que el resto de componentes están dedicadas principalmente a la alimentación de la propia placa, con la excepción del chip Atmega 16u2 que se encarga de gestionar la conexión a través del puerto USB con el ordenador, sin contar los conectores que facilitan el conexionado de los diferentes elementos.

El núcleo del Atmega 2560 está basado en una arquitectura AVR de 8~bits. AVR utiliza una arquitectura Harvard, de forma que la CPU dispone de buses independientes para datos y programa. El ciclo de instrucción está segmentado en dos partes: mientras una instrucción es ejecutada, la siguiente está siendo obtenida desde la memoria Flash. De esta forma, se ejecuta una instrucción por ciclo.

\figura{atmel2560_diagrama.jpg}{scale=0.7}{Diagrama de la arquitectura AVR}{atmel2560}{H}

Como se puede ver en la figura~\ref{atmel2560}, el núcleo AVR consta de 32 registros de 8 bits de propósito general en los que se almacenan los datos que serán procesados en la unidad aritmético-lógica (ALU). Esta unidad soporta operaciones aritméticas y lógicas entre registros o entre un registro y una constante guardando el resultado de nuevo en los registros, en un solo ciclo. Estas operaciones son llevadas a cabo sobre operandos de 8 bits (el tamaño de cada registro) por lo que cualquier operación sobre números enteros de 32~bits (operación habitual en muchas aplicaciones) requerirá más ciclos. Las operaciones aritméticas que puede realizar esta ALU son suma, resta y multiplicación de números de coma fija; sin embargo no dispone de una instrucción de división, por lo que es necesario usar una que funcione mediante software. Tampoco tiene una unidad de coma flotante (FPU) por lo que estamos limitados a números en coma fija o a la emulación de coma flotante a través de bibliotecas, que es lo que sucede cuando usamos variables de tipo `float' durante el desarrollo de una aplicación para Arduino.

Este microcontrolador incluye varios periféricos. Posee un total de 6 temporizadores/contadores, dos de ellos de 8~bits y los otros 4 de 16~bits de resolución. También tiene un RTC (Real Time Counter) que permite llevar la cuenta del tiempo real con un oscilador externo conectado al pin TOSC1. Si observamos el esquemático del Arduino Mega vemos que ese pin no está conectado a nada, es decir, no contiene un oscilador, y tampoco está asociado con ninguno de los conectores disponibles en la placa, por lo que no podremos usar esta funcionalidad. Otros periféricos que encontramos en este chip son 2 interfaces serie: SPI y 2-wire, y un temporizador programable `watchdog' que requiere también un oscilador externo, por lo que tampoco podremos hacer uso de esta característica con la placa Arduino. Por último, también tiene la capacidad de generar interrupciones cuando algún pin cambia su valor, por lo que no será necesario estar activamente esperando durante la ejecución del programa.

\section{ChipKIT Max32}
La placa microcontroladora elegida para el trabajo es una ChipKIT Max32 de DigilentINC.\@ Es el modelo más avanzado de la familia ChipKIT, que se compone además del Uno32, uC32 y DP32.

\figura{chipKIT-Max32.jpg}{scale=0.6}{Chipkit Max32}{max32}{H}

En el centro del Max32 encontramos como microcontrolador un Microchip PIC32MX795F12L que funciona a 80~MHz y con el que disponemos de 512~KB de memoria flash y 128~KB de memoria RAM.\@ Sin embargo, a diferencia del Arduino Mega, no incluye memoria EEPROM en el chip por lo que no podemos almacenar datos de forma no volátil, al menos de una forma tan sencilla como en la placa Arduino. 

El Max32 tiene 83 puertos de entrada/salida además de otros dispositivos como UART, SPI e I2C. Dieciséis de los 83 puertos pueden ser usados como entradas analógicas o como entradas/salidas digitales. A diferencia de su equivalente Arduino (Mega), el ChipKIT Max32 también tiene integrado en su MCU:
\begin{itemize}
 \item 1 módulo 10/100 Ethernet
 \item 1 controlador USB 2.0
 \item 2 controladores CAN 
 \end{itemize} 
 
Para hacer uso de estos dispositivos necesitaremos realizar el cableado apropiado, poner nuestros propios conectores o utilizar la placa ChipKIT Network Shield que ya incluye estos conectores y se puede "pinchar" directamente en los conectores presentes en la ChipKit Max32. 

Al igual que el Arduino Mega, el microcontrolador de esta placa también tiene un RTC (Real Time Clock) que nos permita mantener la hora actual siempre que esté conectado a alguna fuente de alimentación. Para poder usar esta característica es necesario conectar un cristal de cuarzo que funcione a 32~768~kHz al pin correspondiente. En este caso, a diferencia del Arduino Mega, el pin del oscilador se encuentra asignado a uno de los pines de entrada/salida en los conectores de la placa por lo que podremos hacer uso de este periférico.\footnote{En el ChipKIT Uno32 podemos encontrar dos agujeros en la placa donde es posible soldar directamente un cristal para el RTC.}

Este dispositivo, al igual que el resto de microcontroladores de la familia ChipKIT, funciona con un voltaje lógico de 3,3~V frente a los microcontroladores Arduino como el Uno o el Mega que usan un voltaje de 5~V. Esto quiere decir que el nivel lógico alto en el MAX32 es 3.3~V, por lo tanto, al igual que pasaba en el caso de accesorios cuyo voltaje lógico fuese 3.3~V con el Arduino, es necesario tenerlo en cuenta al conectar, por ejemplo, \textit{Shields} Arduino al ChipKIT.

En el caso del Arduino con accesorios que funcionaban a 3.3~V no había problema cuando era el Arduino el que recibía señales con este voltaje porque su umbral de detección lógico está muy por debajo de este valor. Sin embargo es posible que esto no ocurra con otros dispositivos con un nivel lógico de 5~V, por ejemplo dispositivos basados en tecnología CMOS (AC-HC ó AHC-C) cuyo umral de detección (nivel alto) es generalmente de 3.7~V~\footnote{http://www.interfacebus.com/voltage\_threshold.html}.

Por otro lado, el MAX32 puede recibir señales con un nivel lógico de 5~V en sus entradas digitales sin dañarse por lo que no podría ser dañado por un \textit{Shield} de Arduino.

Podemos encontrar más información, además de esquemáticos y manuales en la página de información del ChipKIT Max32 en la web de Digilent.\cite{website:max32}

El microcontrolador que utiliza la placa Max32, el PIC32MX795F512L~\cite{website:pic32mx}, es el modelo más avanzado de la familia PIC32MX de Microchip. Como su nombre indica, se trata de un procesador de 32~bits, frente a los 8 del Atmel. Su arquitectura, aunque también basada en Harvard, es completamente diferente de la del Atmega. Se trata de la arquitectura MIPS32~\footnote{\url{http://www.imgtec.com/mips/architectures/mips32.asp}}, en su versión M4K~\cite{website:m4k_analysis}. Este núcleo consta de 32 registros de propósito general de 32~bits. También cuenta con otro juego de 32 registros (shadow registers) que usa durante interrupciones. De esta forma, cuando se produce alguna interrupción no es necesario guardar los registros principales por lo que la transición de un estado a otro es más rápida.

Como se puede apreciar en la figura~\ref{m4kdiagrama} este chip cuenta con una MDU (unidad de multiplicación y división), un coprocesador y una unidad de administración de memoria (MMU). Ninguno de estas unidades podemos encontrarlas en el chip de Atmel.

La unidad de administración de memoria utiliza un mecanismo FMT (Fixed Mapping Translation) que es más simple y pequeño que el mecanismo TLB (Translation Lookaside Buffer) que puede se puede encontrar en otros núcleos MIPS.\@ Al igual que hace el TLB, FMT realiza la conversión entre direcciones virtuales y direcciones físicas y proporciona atributos para los diferentes segmentos de memoria.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[
		decoration={
			markings,
			mark=at position 1 with {\arrow[ultra thick]{latex}},
		},
		path/.style={
			postaction=decorate,
		},
%		every node/.style={font=\sffamily}
	]
	% Boxes
	\node[
		draw,
		xshift=-6cm,
		yshift=1.5cm,
		minimum width=2cm,
		text width= 2.5cm,
	] (Instr_addr_calc) {Calculador de direcciones de instrucción};
	\node[
		draw,
		xshift=-6cm,
		yshift=-1.5cm,
		minimum width=2cm,
		text width= 2.5cm,
	] (Data_addr_calc) {Calculador de direcciones de datos};
	\node[
		draw,
		xshift=-2cm,
		minimum width=2cm,
		minimum height=5cm,
	] (FMT) {FMT};
	\node[
		draw,
		xshift=2cm,
		minimum width=2cm,
		minimum height=5cm,
		text width=2cm,
] (SRAM_inter) {Interfaz SRAM};
	\node[
		draw,
		xshift=6cm,
		yshift=1.5cm,
		minimum width=2cm,
] (SRAM_instn) {SRAM Instrucciones};
	\node[
		draw,
		xshift=6cm,
		yshift=-1.5cm,
		minimum width=2cm,
] (SRAM_data) {SRAM Datos};

% Conexiones
\draw[path] (Instr_addr_calc.east) -- ++(1,0) node[above,text width=2cm]{Dirección Virtual} |- ([yshift=-1cm] FMT.north west);
\draw[path] (Data_addr_calc.east) -- ++(1,0) node[below,text width=2cm]{Dirección Virtual} |- ([yshift=1cm]FMT.south west);
\draw[path] ([yshift=-1cm]FMT.north east) -- ++(1,0) node[above,text width=2cm]{Dirección Física} |- ([yshift=-1cm] SRAM_inter.north west);
\draw[path] ([yshift=1cm]FMT.south east) -- ++(1,0) node[below,text width=2cm]{Dirección Física} |- ([yshift=1cm] SRAM_inter.south west);
\draw[path] ([yshift=-1cm]SRAM_inter.north east) |- (SRAM_instn.west);
\draw[path] ([yshift=1cm]SRAM_inter.south east) |- (SRAM_data.west);

\end{tikzpicture}
\end{center}
\caption{Traducción de direcciones en M4K}
\label{mmu_m4k}
\end{figure}
El MDU nos permite realizar multiplicaciones entre operandos de 16~bits (o uno de 16 y otro de 32~bits) en un solo ciclo y entre dos operandos de 32~bits en dos o tres ciclos frente al ciclo que tarda la multiplicación de dos operandos de 8 bits en el núcleo AVR.\@ Además, con esta unidad se pueden realizar divisiones mediante hardware sin tener usar bibliotecas (como pasa con el Atmega) gracias a su divisor, y el tiempo de estas operaciones es de 35 ciclos de reloj en el peor de los casos. La MDU implementa un divisor sin restauración~\footnote{url{http://stackoverflow.com/questions/12133810/non-restoring-division-algorithm}}.

\figura{m4k_diagram.jpg}{scale=0.7}{Diagrama del Núcleo M4K}{m4kdiagrama}{H}

El coprocesador es una interfaz de registros que sirve para comunicar información de control y estado entre el programa y la CPU.\@ A través del coprocesador tenemos acceso al `core timer', al control de interrupciones y excepciones, a la configuración del espacio virtual de memoria, al control de los registros `shadow', a la identificación del procesador y al control de depuración.

\figura{m4k_pipeline.jpg}{scale=0.7}{Segmentación (simplificada) en MIPS}{mipspipeline}{H}

MIPS fue desarrollada por John L. Hennessy y su equipo como una arquitectura de tipo RISC de 32~bits. Al igual que AVR, MIPS cuenta con segmentación de instrucciones, pero dividido en 5 etapas mostradas en la figura~\ref{mipspipeline}. Estas etapas son: Instruction Fetch, Execution, Memory Fetch, Align y Writeback. Podemos encontrar una descripción detallada de los procesos que se llevan a cabo en cada una de ellas en el apartado 2.3 del manual de referencia de PIC32MX accesible a través de la página web del PIC32MX795F512L~\cite{website:pic32mx}. Este microcontrolador también incluye mecanismos para evitar las interrupciones en la ejecución de instrucciones por dependencia de datos. Para ello utiliza realimentación de forma que la etapa de ejecución puede obtener operandos directamente desde la etapa `M' o la etapa `A' como se puede ver en la figura~\ref{mipspipeline}. Usando la realimentación se puede enviar los operandos desde una de esas etapas reduciendo posibles ciclos de espera. El incremento en rendimiento en operaciones que involucren a la ALU supone alcanzar una instrucción por ciclo incluso con la presencia de dependencia de registros.

Desde el punto de vista académico, usar este microcontrolador con arquitectura MIPS frente al Atmel y su AVR tiene la ventaja de que MIPS se estudia en multitud de asignaturas en universidades de todo el mundo. Esto ayuda a la hora de desarrollar programas al estar ya familiarizado con el juego de instrucciones y su segmentación de instrucciones, incluyendo los riesgos de control y datos, y cómo se reducen.

\section{Accesorios}
Durante el desarrollo de esta trabajo se ha utilizado varios accesorios junto con el ChipKIT MAX32 que facilitaron tareas como depurar programas, conectar la placa a la red Ethernet o proporcionar elementos de entrada-salida como LEDs, botones o una pantalla OLED.\@
\subsection{Chipkit PGM}
Para la depuración de los programas con MPLAB se ha utilizado el programador chipKIT PGM\cite{website:pgm}, con el que he podido usar el puerto JTAG del Max32. Este programador está diseñado por Digilent (Fabricante de las placas ChipKIT) para ser usado con la familia de dispositivos chipKIT.\@ Microchip también dispone de su propio programador, el picKIT3~\cite{website:pickit}, con el que se podría también programar estos microcontroladores. Las principales diferencias entre el ChipKIT PGM y el picKIT es que el primero esta diseñado solamente para ser usado con microcontroladores que funcionen con un voltaje de 3.3 V mientras que el programador de Microchip puede ser usado también con dispositivos que funcionen a 5~V. El precio del ChipKIT PGM es inferior al del PicKIT, lo que lo hace la opción adecuada para este trabajo, al utilizar exclusivamente una placa microcontroladora ChipKIT.

\figura{chipKIT-PGM.png}{scale=0.3}{ChipKIT PGM}{pgm}{H}

\subsection{ChipKIT Basic I/O Shield}
El otro shield que he usado será el ChipKIT Basic I/O Shield que nos servirá para interactuar físicamente con el microcontrolador ya que este shield nos proporciona diferentes métodos de entrada y salida de información así como conectores de utilización más sencilla y robusta.

\figura{chipKIT-BasicIOShield.jpg}{scale=0.5}{ChipKIT Basic I/O Shield}{ioshield}{H}

El ChipKIT Basic I/O shield dispone de los siguientes dispositivos:
\begin{itemize}
	\item EEPROM de 256~Kbits con interfaz I2C
	\item Pantalla OLED de 128$\times$32 píxeles
	\item Sensor de temperatura con interfaz I2C
	\item Conector para cadena margarita (daisy chain) I2C
	\item 4 drivers FET de colector abierto
	\item Potenciometro analógico
	\item 4 pulsadores y cuatro interruptores
	\item 8 LEDs
\end{itemize}

Este shield está inicialmente pensado para ser usado en un chipKIT Uno32, pero podemos conectarlo al Max32 sin ningún problema ya que comparten el mismo esquema de pines (aunque el Max32 tiene 83 pines frente a los 42 del Uno32). También es posible conectarlo al Network Shield y este a su vez al Max32, teniendo en cuenta la posibilidad de que algunas funciones en los dos shields sean incompatibles al utilizar los mismos pines del PIC32 para funciones diferentes. Este hecho se conoce como multiplexación de funciones.

Igual que el Network Shield, el Basic I/O Shield también dispone de una página web~\cite{website:io_shield} en la que podemos encontrar su manual, esquemáticos y las bibliotecas necesarias para usar en el entorno ChipKIT.\@
\subsection{ChipKIT Network Shield}

El ChipKIT Network Shield es, como su nombre indica, un shield para el ChipKIT MAX32.\@ Cabe destacar que este shield no sirve para el ChipKIT Uno32 puesto que el microcontrolador que está montado en ella no dispone de las características de las que hace uso esta placa, como Ethernet y host USB.\@ Se coloca encima del microcontrolador tal y como lo hace cualquier shield de Arduino.

\figura{chipKIT-NetworkShield.jpg}{scale=0.5}{Chipkit Network Shield}{networkshield}{H}

Este shield nos proporciona las conexiones necesarias para poder hacer uso del controlador Ethernet y USB que lleva el Max32 integrado y a los buses CAN.\@ Además de esto también tiene integrado un oscilador de 32~768 KHz que nos permite hacer uso del RTC que también tiene integrado el Max32 y una memoria EEPROM de 256~Kb a la que podemos acceder mediante I2C. En la página web del Network Shield~\cite{website:network_shield} podemos encontrar las bibliotecas que nos sirven para hacer uso de sus características, en el entorno ChipKIT.\@

% yo comentaría un poco más cada una de las características: un parrafo resumen de su posible aplicación. 
Características del ChipKIT Network Shield:
\begin{itemize}
	\item Puede ser usado con el Max32
	\item SMSC LAN8720 10/100 Ethernet PHY
	\item Conector RJ45
	\item Dispositivo USB y conectores Host
	\item 2 transceptores CAN MCP2551
	\item 2 conectores de 12 pines para los buses CAN
	\item 2 conectores para cadena margarita (daisy chain) I2C
	\item EEPROM de 256~Kbits con interfaz I2~C
	\item Oscilador a 32~768~KHz
\end{itemize}


