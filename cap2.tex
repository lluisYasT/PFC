% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

\section{Hardware}
En esta sección se describirán los dispositivos que van a ser utilizados para la realización del proyecto.

\subsection{ChipKIT Max32}
El microcontrolador elegido para el proyecto es un ChipKIT Max32. Es el modelo más avanzado de la familia Chipkit, que se compone además del Uno32, uC32 y DP32.

\figura{chipKIT-Max32.jpg}{scale=0.6}{Chipkit Max32}{max32}{H}

En el centro del Max32 encontramos como microcontrolador un Microchip PIC32MX795F12L que funciona a 80MHz y con el que disponemos de 512KB de memoria flash y 128KB de memoria RAM. El Max32 tiene 83 puertos de entrada/salida además de otros dispositivos como UART, SPI e I2C. Dieciséis de los 83 puertos puede ser usados como entradas analógicas o como entradas/salidas digitales. A diferencia de su equivalente Arduino (Mega), el ChipKIT Max32 también tiene integrado en el chip 10/100 Ethernet, un controlador USB 2.0 y dos controladores CAN, aunque para hacer uso de estos dispositivos necesitaremos el ChipKIT Network Shield.\\

Este dispositivo, al igual que el resto de microcontroladores de la familia ChipKIT, funciona con un voltaje lógico de 3.3V frente a los microcontroladores Arduino como el Uno o el Mega. Es importante tener este dato en cuenta a la hora de usar shields o dispositivos pensados para placas Arduino.\\

Podemos encontrar más información además de esquemáticos y manuales en la página de información del ChipKIT Max32\cite{website:max32}.\\

Características del ChipKIT Max32:
\begin{itemize}
	\item Procesador Microchip PIC32MX795F512L
		\begin{itemize}
			\item 80MHz 32-bit MIPS
			\item 512KB FLash, 128KB RAM
			\item Controlador USB 2.0 OTG
			\item 10/100 Ethernet MAC
			\item Dos controladores CAN
		\end{itemize}
	\item Proporciona memoria adicional (con respecto al Uno32) y periféricos de comunicación avanzados
	\item Compatible con gran parte del código existente de ejemplo para Arduino, así como con materiales de referencia y otros recursos.
	\item Puede ser programado usando Microchip MPLAB, mediante un programador gracias a su interfaz JTAG.
	\item Mismo tamaño y formato que el Arduino Mega
	\item 83 pines de entrada/salida
	\item LED de usuario (Pin 13)
	\item Se conecta a un PC usando un cable USB A -> mini B
\end{itemize}

\subsubsection{Chipkit PGM}
Para la depuración de los programas con MPLAB usaremos el programador chipKIT PGM\cite{website:pgm}, con el que podremos usar el puerto JTAG del Max32. Este programador está diseñado para ser usado exclusivamente con la familia de dispositivos chipKIT, a diferencia de picKIT3\cite{website:pickit} que puede ser usado con todos los microcontroladores de Microchip.

\figura{chipKIT-PGM.png}{scale=0.3}{ChipKIT PGM}{pgm}{H}

\newpage

\subsection{ChipKIT Network Shield}

El ChipKIT Network Shield es, como su nombre indica, un shield para el ChipKIT Max32. Cabe destacar que este shield no sirve para el ChipKIT Uno32 puesto que este microcontrolador no dispone de las características de las que hace uso este shield, como Ethernet y host USB.Se coloca encima del microcontrolador tal y como lo hace cualquier shield de Arduino.

\figura{chipKIT-NetworkShield.jpg}{scale=0.5}{Chipkit Network Shield}{networkshield}{H}

Este shield nos proporciona las conexiones necesarias para poder hacer uso del controlador Ethernet y USB que lleva el Max32 integrado y a los buses CAN. Además de esto también tiene integrado un oscilador de 32.768 KHz que nos permite hacer uso del RTC que también tiene integrado el Max32 y una memoria EEPROM de 256Kb a la que podemos acceder mediante I2C. En la página web del Network Shield\cite{website:network_shield} podemos encontrar las bibliotecas que nos sirven para hacer uso de sus características, en el entorno ChipKIT.\\

Características del ChipKIT Network Shield:
\begin{itemize}
	\item Puede ser usado con el Max32
	\item SMSC LAN8720 10/100 Ethernet PHY
	\item Conector RJ45
	\item Dispositivo USB y conectores Host
	\item Dos transceptores CAN MCP2551
	\item Dos conectores de 12 pines para los buses CAN
	\item Dos conectores para cadena margarita (daisy chain) I2C
	\item EEPROM de 256Kbits con interfaz I2C
	\item Oscilador a 32.768 KHz
\end{itemize}

\newpage


\subsection{ChipKIT Basic I/O Shield}
El otro shield que usaremos será el ChipKIT Basic I/O Shield que nos servirá para interactuar físicamente con el microcontrolador ya que este shield nos proporciona diferentes métodos de entrada y salida de información.

\figura{chipKIT-BasicIOShield.jpg}{scale=0.5}{ChipKIT Basic I/O Shield}{ioshield}{H}

El ChipKIT Basic I/O shield dispone de los siguientes dispositivos:
\begin{itemize}
	\item EEPROM de 256Kbits con interfaz I2C
	\item Pantalla OLED de 128x32 píxeles
	\item Sensor de temperatura con interfaz I2C
	\item Conector para cadena margarita (daisy chain) I2C
	\item Cuatro drivers FET de colector abierto
	\item Potenciometro analógico
	\item Cuatro pulsadores y cuatro interuptores
	\item Ocho LEDs
\end{itemize}

Este shield está inicialmente pensado para ser usado en un chipKIT Uno32, pero podemos conectarlo al Max32 sin ningún problema ya que comparten el mismo esquema de pines (aunque el Max32 tiene 83 pines frente a los 42 del Uno32). También es posible conectarlo al Network Shield y este a su vez al Max32, teniendo en cuenta la posibilidad de que algunas funciones en los dos shields puedan compartir pines.\\

Igual que el Network Shield, el Basic I/O Shield también dispone de una página web\cite{website:io_shield} en la que podemos encontrar su manual, esquemáticos y las librerías necesarias para usarlas en el entorno ChipKIT.

\newpage

\section{Software} A lo largo del proyecto utilizaremos dos entornos de
desarrollo integrado: \programa{MPIDE} y \programa{MPLAB X}.
\subsection{\programa{MPIDE}} \programa{MPIDE}\cite{website:mpide} es el IDE
creado por Digilent para el entorno ChipKIT. Su diseño es idéntico al IDE de
Arduino, variando solamente el color y el compilador usado.
\figura{mpide.jpg}{scale=0.6}{\programa{MPIDE}}{mpide}{H} \programa{MPIDE} es
un entorno de desarrollo sencillo y con unas características muy básicas y
limitadas. Con él podremos escribir nuestro programa, compilarlo y cargarlo en
nuestro microcontrolador sin necesidad de ninguna otra aplicación, siempre y
cuando hayamos seleccionado el modelo adecuado y el puerto serie en las
opciones del programa. \\ Al igual que el entorno de Arduino, no es posible
depurar programas, para eso usaremos \programa{MPLAB X}. También dispone de un monitor
para el puerto serie, con el que podemos leer lo que el microcontrolador envía
a través de este puerto y enviar información al microcontrolador.
\subsection{\programa{MPLAB X}} \programa{MPLAB X}\cite{website:mplab} es la última versión del
entorno de desarrollo integrado de Microchip. A diferencia de
\programa{MPIDE}, este programa es un IDE completo, basado en Netbeans. Está
pensado para ser utilizado con toda su gama de microcontroladores y, con la
ayuda de un depurador/programador como el chipKIT PGM podremos depurar
nuestros programas. Si queremos, también podemos usar los productos chipKIT
como cualquier otro microcontrolador de Microchip, escribiendo los programas
en este IDE y compilándolos con el compilador que tiene Microchip disponible
en su página web, C32\cite{website:c32}. \figura{mplab.jpg}{scale=0.35}{MPLAB
X Depurando}{mplab}{H}

Como se aprecia en la Figura \ref{mplab} \programa{MPLAB X} nos ofrece mucha más información y posibilidades que \programa{MPIDE}. En esta figura vemos a \programa{MPLAB X} en mitad de la depuración del programa Blink, que fue compilado usando \programa{MPIDE}.\\
Con este entorno de desarrollo veremos más adelante los diferentes efectos de que los distintos niveles de optimización tienen en nuestro programa y podremos usarla para hacer profiling.


\section{Estructura de un programa Arduino}
En cualquier programa para Chipkit o Arduino podemos encontrar tres grupos principales de código fuente.
\subsection{Core}
Para empezar, tenemos los archivos que formarán parte de la biblioteca ``Core'' a la hora de la compilación. Estos archivos vienen incluidos con \programa{MPIDE} y los podemos encontrar en el directorio en el que tengamos instalado \programa{MPIDE}\footnote{La carpeta de \programa{MPIDE} la podemos colocar donde queramos, pues no requiere de instalación}, en la subcarpeta:\\
\comando{hardware/pic32/cores/pic32}
\begin{table}[H]
\begin{center}
\begin{tabular}{| c || c |}
    \hline
    Sistema Operativo & Ruta\\
    \hline
    \hline
    Linux & /home/lluis/mpide/hardware/pic32/cores/pic32\\
    \hline
    Mac OSX & /Applications/Mpide.app/Contents/Resources/Java/hardware/pic32/cores/pic32\\
    \hline
    Windows & C:\textbackslash Archivos de Programa\textbackslash \programa{MPIDE}\textbackslash hardware\textbackslash pic32\textbackslash cores\textbackslash pic32\\
    \hline
  \end{tabular}
\end{center}
\caption{Ruta de la biblioteca Core}
\label{tab:core_path}
\end{table}
En esta biblioteca tenemos ya definidas las funciones que necesitamos para interactuar con los dispositivos que están integrados en la placa (en nuestro caso ChipKIT Max32). Para más información acerca de estas funciones y como utilizarlas podemos acudir a la página de referencia de Arduino\cite{website:arduino_funcs}.
Además, en esta biblioteca está ya definida la función main de nuestro programa y tiene el siguiente aspecto:
\lstset{language=C++}
\begin{lstlisting}[caption=main.cpp]
#define OPT_SYSTEM_INTERNAL
#include <System_Defs.h>

#if (ARDUINO >= 100)
	#include <Arduino.h>
#else
	#include <WProgram.h>
#endif

int main(void)
{
	init();
	setup();
	
	while(1)
	{
		_scheduleTask();
		loop();
	}
	return 0;
}
\end{lstlisting}

\subsection{Sketch}
Los programas que escribimos usando \programa{MPIDE} (o el IDE de Arduino) se llaman sketches. En realidad, no escribimos un programa completo porque, como acabamos de ver, el programa en sí ya está escrito en la biblioteca Core. Nuestro objetivo es implementar dos funciones: \comando{setup()} y \comando{loop()}, que ya están declaradas en el archivo de cabecera wiring.h.\\
\begin{lstlisting}[caption=Sección de wiring.h]
void setup(void);
void loop(void);
\end{lstlisting}

Como se puede apreciar en la declaración de ambas funciones, estas no esperan ni devuelven ningún valor.\\
\lstinputlisting[language=C++, caption=Sketch básico ("BareMinimum.pde")]{codigo_fuente/BareMinimum.pde}
En \comando{setup()} colocaremos el código para la inicialización de nuestro programa. Es el lugar donde podemos configurar el puerto serie, por ejemplo, o definir como se comportarán los pines (entrada o salida), entre otras cosas. En definitiva, es el lugar donde debemos colocar el código que queramos que se ejecuta una vez al inicio del programa y que no vuelva a ejecutarse más.\\
En \comando{loop()} pondremos el código que se ejecutara de forma cíclica indefinidamente ya que, como podemos observar en main.cpp, la función \comando{loop()} se encuentra dentro de un bucle infinito.\\

Veamos como ejemplo el sketch Blink:
\lstinputlisting[language=C++, caption=Blink.pde, label=code:blink]{codigo_fuente/Blink.pde}

En este sketch utilizamos las funciones de Arduino pinMode,digitalWrite y delay. En la función \comando{setup()} inicializamos el puerto al que está conectado el LED como una salida\footnote{PIN\_LED1 está definido en el archivo de cabecera Board\_Defs.h que depende del modelo de microcontrolador que estemos usando}, mientras que en \comando{loop()} encendemos y apagamos el LED con retardos de un segundo.

\subsection{Bibliotecas de terceros}
A parte del código de Arduino y del que creemos nosotros, también es posible añadir bibliotecas de terceros. Gracias a la amplia comunidad detrás de Arduino podemos encontrar cientos de ellas. A la hora de usar una biblioteca de Arduino en ChipKIT tendremos que asegurarnos de que no haga uso de funciones específicas de los procesadores Atmel que encontramos en las placas Arduino, ya que no funcionarán en PIC32.\\
Cuando trabajamos con \programa{MPIDE} podemos encontrar las bibliotecas en dos sitios diferentes. \programa{MPIDE} tiene incluidas varias bibliotecas que podemos encontrar en el directorio ``libraries'' dentro de la carpeta en la que esté instalado \programa{MPIDE}. A parte de estas bibliotecas podemos instalar bibliotecas que descarguemos de Internet o que creemos nosotros dentro de la carpeta ``libraries'' en el directorio ``sketchbook''\footnote{La carpeta ``libraries'' no existe. Es neciesario crearla dentro del directorio ``sketchbook''.} que \programa{MPIDE} habrá creado la primera vez que lo ejecutemos.\\
Con las bibliotecas instaladas en uno de los dos directorios podremos añadirlas a nuestro programa de dos formas diferentes. Podemos añadirlas usando el menú de MPIDE, pudiéndolas encontrar en \comando{Sketch > Import Library}. También es posible usar la directiva \comando{\#include <[Archivo De Cabezera].h>} como haríamos en cualquier programa escrito en C/C++. \programa{MPIDE} se encargará de compilar las bibliotecas y enlazarlas con nuestro programa.

\section{Proceso de compilación de \programa{MPIDE}}
En este apartado trataremos de describir el proceso que sigue \programa{MPIDE} para la compilación y posterior carga en el microcontrolador del programa creado en \programa{MPIDE}. Nuestro objetivo será saber que programas y opciones de compilación usa el IDE de ChipKIT.\\
También es interesante conocer que archivos genera \programa{MPIDE} a lo largo de la compilación, pero estos archivos son borrados una vez termina la compilación del programa por lo que tendremos que cambiar este comportamiento. Para ello acudiremos al archivo de configuración \comando{preferences.txt} cuya localización varía según el sistema operativo empleado.

\begin{table}[H]
\begin{center}
\begin{tabular}{| c || c |}
    \hline
    Sistema Operativo & Ruta\\
    \hline
    \hline
    Linux & /home/[nombre de usuario]/.mpide/preferences.txt\\
    \hline
    Mac OSX & /Users/[nombre de usuario]/Library/mpide/preferences.txt\\
    \hline
    Windows & C:\textbackslash Archivos de Programa\textbackslash \programa{MPIDE}\textbackslash hardware\textbackslash pic32\textbackslash cores\textbackslash pic32\\
    \hline
  \end{tabular}
\end{center}
\caption{Ruta del archivo \comando{preferences.txt}}
\label{tab:preferences_path}
\end{table}

El archivo \comando{preferences.txt} contiene toda la configuración de MPIDE a excepción de la configuración del compilador, pero nosotros estamos interesados en la línea 75:
\begin{lstlisting}
preproc.save_build_files=false
\end{lstlisting}

Cambiando el valor a \comando{true} \programa{MPIDE} guardará los archivos temporales de la compilación.\\
Para ver como funciona el proceso de compilación en \programa{MPIDE} usaremos el sketch Blink (\ref{code:blink}).\\
Para ver que se ejecuta cuando compilamos nuestro programa en \programa{MPIDE} podemos mantaner pulsado la tecla \comando{Mayus} mientras pulsamos el botón de compilar. De esta forma \programa{MPIDE} nos mostrará todos los comandos que ejecute, en el terminal.

\figura{mpide_compilado.jpg}{scale=0.6}{MPIDE después de compilar}{mpide_compilado}{H}

El proceso completo de compilación (lo que se muestra en el terminal) está en el Apéndice \ref{chap:apendice1}\\

Veamos que pasos sigue \programa{MPIDE} durante la compilación y ensamblado de nuestro programa:
\begin{enumerate}
	\item MPIDE comienza copiando nuestro sketch y las bibliotecas que hayamos incluído a una carpeta temporal en la que se realizará el proceso de compilación y ensamblado.
	\item Añade al sketch la extensión `.cpp' para compilarlo. Además, si hemos escrito alguna función a parte de \comando{loop()} y \comando{setup()} se encargará de declararla por nosotros e incluirá el archivo de cabecera \programa{WProgram.h}.
	\item Compila, usando \programa{pic32-g++} (sin enlazar) Blink.cpp (este archivo es una copia de nuestro sketch, Blink.pde).
	\item Compila y comprime la biblioteca ``Core'' usando \programa{pic32-g++} (o \programa{pic32-gcc} según el caso) y \programa{pic32-ar}.
	\item Enlaza el programa usando un script de enlazado común a todos las diferentes placas chipKIT: ``chipKIT-application-COMMON.ld'', y uno específico para cada microcontrolador. En nuestro caso usa ``chipKIT-application-32MX795F12.ld''.
\end{enumerate}

\subsection{Parámetros de compilación}
\programa{MPIDE} utiliza diferentes parámetros a la hora de la compilación y posterior enlazado. Veamos cuales son:\\

\begin{itemize}
	\item \negrita{-ON}. Nivel de optimización. El valor ``N'' varía entre 0 y 3 para optimizaciones generales. Si su valor es ``s'' optimizamos para reducir el espacio que ocupa el programa.
	\item \negrita{-mno-smart-io}. Esta opción deshabilita el análisis estadístico de las cadenas con format que son pasadas a \comando{printf} o \comando{scanf} y a las variaciones `f' y `v' de estas funciones.
	\item \negrita{-w}. Esta opción deshabilitia todos los mensajes de advertencia.
	\item \negrita{-fno-exceptions}. Esta opción deshabilita el manejo de excepciones.
	\item \negrita{-ffunction-sections}. Con esta opción cada función se coloca en su propia sección en el archivo de salida.
	\item \negrita{-fdata-sections}.Con esta opción cada dato se coloca en su propia sección en el archivo de salida.
	\item \negrita{-g}. Produce información para la depuración
	\item \negrita{-mdebugger}. Esta opción define el símbolo ``\_DEBUGGER'', lo que reservara espacio en una sección del archivo de salida (.DBG\_EXCPT) para los vectores de excepción de depuración.
	\item \negrita{-Wcast-align}. Está opción hace que el compilador lance una advertencia cuando a un puntero se le ha hecho un cast. Por ejemplo, advierte si \comando{const char *} se convierte en \comando{int *}.
	\item \negrita{-fno-short-double}. Esta opción hace que el tipo de variable \comando{double} sea equivalente a \comando{long double} en vez de a \comando{float}, que es la opción por defecto.
	\item \negrita{-mprocessor=?}. Esta opción indica al compilador cual es el procesador objetivo. En nuestro caso particular se trata de ``32MX795F512L''.
	\item Definiciones de macros para el preprocesador.
	\begin{itemize}
		\item \negrita{-DF\_CPU=?}. Este macro define la frecuencia a la que funciona el procesador. En este caso ``80000000L''.
		\item \negrita{-DARDUINO}. Definimos el macro ``ARDUINO'' con valor 1.
		\item \negrita{-D\_BOARD\_MEGA\_}.Definimos el macro ``\_BOARD\_MEGA\_'' con valor 1. Indica que estamos usando una placa con el formato de un Arduino Mega.
		\item \negrita{-DMPIDEVER=?}. Definimos el valor de ``MPIDEVER'', que es ``0x01000305''.
		\item \negrita{-DMPIDE=?}. Definimos la versión de \programa{MPIDE} que hemos usado. En nuestro caso es la versión 23.
	\end{itemize}
	\item Parámetros de enlazado:
		\begin{itemize}
			\item \negrita{-Os}. Optimizamos para espacio.
			\item \negrita{-Wl,--gc-sections}. Usando ``-Wl'' pasamos opciones al enlazador, separadas por comas. En este caso pasamos la opción ``--gc-sections'' que sirve para eliminar todo el código y datos que vayan a ser usados por el programa final.
			\item \negrita{-mdebugger}. Misma opción que antes.
			\item \negrita{-mprocessor=?}. Misma opción que antes.
			\item \negrita{-lm}. Enlaza la librería ``math'' que nos proporciona funciones matemáticas\footnote{http://en.wikipedia.org/wiki/C\_mathematical\_functions}
			\item \negrita{-T}. Con esta opción podemos especificar un script de enlazado. Se usa dos veces: Una para el script ``chipKIT-application-COMMON.ld'' y otra para ``chipKIT-application-32MX795F512.ld''.
		\end{itemize}
\end{itemize}

Una vez el programa está compilado y enlazado\footnote{Suponemos que el nombre del archivo ejecutable es sketch.elf (como ejemplo)} es necesario generar el archivo ejecutable con extensión `.hex' que cargaremos en el microcontrolador. Esto lo consigue \programa{MPIDE} usando los programas \programa{pic32-objcopy} y \programa{pic32-bin2hex}.
\begin{lstlisting}[breaklines=true]
pic32-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 sketch.elf sketch.eep
pic32-bin2hex -a sketch.elf
\end{lstlisting}

El resultado de ejecutar estos dos comandos es el archivo ``sketch.hex'' que ya podrá ser cargado al microcontrolador.
Para este último paso será necesario usar el programa \programa{avrdude}, bien el que viene incluido con \programa{MPIDE} o el que tengamos instalado en nuestro sistema.
\begin{lstlisting}[breaklines=true]
avrdude -C[Directorio MPIDE]/hardware/tools/avrdude.conf -c stk500v2 -p pic32 -P /dev/ttyUSB0 -b 115200 -v -U
\end{lstlisting}\footnote{/dev/ttyUSB0 es el puerto serie en el que se encuentra el microcontrolador. Puede cambiar según el sistema o el número de dispositivos serie conectados.}

\newpage

\section{Alternativa a \programa{MPIDE}}

Una vez sabemos como funciona \programa{MPIDE} y el proceso que sigue para la compilación, enlazado y carga de nuestro programa, podemos proponer una alternativa más flexible.  
De esta forma es posible usar el editor de textos que queramos para generar nuestro código (por ejemplo \programa{VIM}), modificar las opciones de compilación, enlazado y carga de una forma rápida y sencilla\footnote{Podemos cambiar las opciones de compilación y enlazado en \programa{MPIDE}, pero requiere la modificación de un archivo de configuración del programa (platforms.txt) y reiniciar \programa{MPIDE} para que los cambios tengan efecto}.\\
Para esto vamos a crear una carpeta a modo de plantilla para los proyectos que hagamos. Dentro de esta carpeta tendremos diferentes subdirectorios que serviran para almacenar diferentes tipos de archivos que necesita nuestro programa.\\
La estructura de la plantilla es la siguiente:
\begin{lstlisting}
chipkit_template
	+- bin
	+- core
	    |
	    +- variants
	+- lib
	+- src
\end{lstlisting}

Función de cada carpeta:
\begin{itemize}
	\item \negrita{bin}. Aquí se guardará el programa compilado y enlazado. En esta carpeta estará el archivo final con extensión `.hex' que será el que carguemos en la placa.
	\item \negrita{core}. Aquí está la biblioteca Arduino (core) junto con los archivos de cabecera de las diferentes placas disponibles. Estos últimos archivos los encontramos en la carpeta ``variants'' y definen las constantes que dependen de la placa que estemos usando tales como, por ejemplo, la ubicación de los pines de entrada/salida.
	\item \negrita{lib}. Aquí se colocarán las bibliotecas de terceros de la misma forma que en MPIDE: copiando la carpeta de la biblioteca en este directorio. Usando el archivo Makefile compilaremos todas las bibliotecas y luego las enlazaremos con nuestro programa y la biblioteca core.
	\item \negrita{src}. Aquí estará el código fuente del programa que hayamos creado. Será el lugar en el que se encuentre el archivo de código fuente \programa{sketch.cpp} que contiene las definiciones de las funciones \comando{setup()} y \comando{loop()}. Además, si necesitamos crear nuestras propias bibliotecas (archivos .h + .c o .cpp) podemos crearlos tanto en esta carpeta o en \programa{lib}.
\end{itemize}
Tanto en la carpeta principal como en \programa{core} tendremos un archivo Makefile para la automatización de los procesos de compilación, ensamblado y posterior carga de nuestro programa.\\
El Makefile principal se encarga de compilar, enlazar y comprimir la biblioteca core en el archivo \programa{core.a} usando el Makefile que se encuentra dentro de esa carpeta y luego compila todos los archivos en la carpeta \programa{lib} y la carpeta{src}. Una vez enlazado podemos usar la orden \comando{make load} para cargar el programa en la placa:
\newpage
\lstinputlisting[language=make, caption=Makefile Principal, label=code:makefile_principal, basicstyle=\tiny, breaklines=true]{codigo_fuente/Makefile_principal}
\newpage
Analicemos el funcionamiento de nuestro Makefile:\\
\lstinputlisting[language=make, firstline=1, lastline=13, breaklines=true]{codigo_fuente/Makefile_principal}
Comenzamos definiendo la localización de \programa{MPIDE}, \programa{avrdude} y el puerto serie. Esto lo hacemos de forma diferente dependiendo de si nos encontremos en Mac OS on en GNU/Linux\footnote{En el caso de Windows el puerto serie suele tener un nombre de la forma COMx, cambiando x por el número de puerto.}. También definimos la localización en la que normalmente podremos encontrar el puerto serie del microcontrolador.

\lstinputlisting[language=make, firstline=14, lastline=20, breaklines=true]{codigo_fuente/Makefile_principal}
Continuamos declarando la localización la `toolchain' que viene incluida con \programa{MPIDE}. La localización de \programa{MPIDE} en este caso es la carpeta \$HOME de mi PC (Es necesario modificar este valor dependiendo de la localización de \programa{MPIDE}). Las utilidades de la `toolchain' que viene incluida con \programa{MPIDE} se encuentran siempre en la misma subcarpeta, que en el Makefile es la variable `TOOLCHAIN\_PREFIX', independientemente del sistema operativo empleado. También exportamos MPIDE de forma que podamos acceder a su valor desde el Makefile que se encuentra en la carpeta \programa{core} y así solo es necesario modificar su valor en este archivo, en caso de que el programa se encuentre en un lugar diferente.\\
rc
\lstinputlisting[language=make, firstline=22, lastline=22, breaklines=true]{codigo_fuente/Makefile_principal}
Definimos las opciones para \programa{avrdude}, que usaremos para cargar el programa en la placa y que viene incluido con \programa{MPIDE}.\\

\lstinputlisting[language=make, firstline=24, lastline=27, breaklines=true]{codigo_fuente/Makefile_principal}
Definimos la CPU que lleva nuestra placa, que en este caso corresponde con el Modelo Microchip 32MX795F12L. También declaramos que placa es\footnote{La placa podría ser cualquiera de los modelos compatibles con Arduino que vende Digilent}, para luego poder usar el archivo de cabecera correspondiente a dicha placa. Estas dos variables las exportamos para que sean accesibles también desde el Makefile que hay en la carpeta `core' y no sea necesario volverlas a definir ahí, de la misma forma que hemos hecho con la variable MPIDE.\\

\lstinputlisting[language=make, firstline=29, lastline=30, breaklines=true]{codigo_fuente/Makefile_principal}
El enlazador utiliza dos scripts para el correcto enlazado del programa: uno común a todas las placas chipKIT (\programa{chipKIT\-application\-COMMON.ld}) y uno específico según el modelo que usemos (\programa{chipKIT\-application-32MX795F512.ld}).

\lstinputlisting[language=make, firstline=32, lastline=37, breaklines=true]{codigo_fuente/Makefile_principal}
Guardamos las opciones de compilación y enlazado en las variables \$CFLAGS y \$LDFLAGS respectivamente.

\lstinputlisting[language=make, firstline=39, lastline=41, breaklines=true]{codigo_fuente/Makefile_principal}
Añadimos al final de las opciones de compilación los directorios donde habrá que buscar los archivos de cabecera de las bibliotecas de terceros.

\lstinputlisting[language=make, firstline=44, lastline=46, breaklines=true]{codigo_fuente/Makefile_principal}
Buscamos en la carpeta `src' los ficheros con código fuente en C, C++ o ensamblador.

\lstinputlisting[language=make, firstline=48, lastline=50, breaklines=true]{codigo_fuente/Makefile_principal}
Generamos los nombres de los archivos compilados y ensamblados sustituyendo la extensión de los archivos de código fuente de la carpeta `src'.

\lstinputlisting[language=make, firstline=52, lastline=58, breaklines=true]{codigo_fuente/Makefile_principal}
Igual que antes, pero esta vez buscamos los archivos con código fuente dentro de la carpeta `lib' que contiene todas las librerías de terceros.

\lstinputlisting[language=make, firstline=60, lastline=60, breaklines=true]{codigo_fuente/Makefile_principal}
Este es el primer objetivo que hay en nuestro Makefile y es el que se ejecutará por defecto cuando ejecutamos \programa{make} sin ningún argumento. Lo utilizamos para definir el objetivo por defecto sin tener que modificar nada más que esta línea del Makefile. En este caso indicamos que este objetivo depende del objetivo `load' que veremos más adelante.

\lstinputlisting[language=make, firstline=62, lastline=63, breaklines=true]{codigo_fuente/Makefile_principal}
Llamamos al Makefile que se encuentra en la carpeta `core' para obtener la biblioteca estática `core/core.a'\footnote{En realidad, este es el programa principal. Nosotros solo nos encargamos de construir las funciones \comando{setup()} y \comando{loop()}, como ya se ha comentado.} que luego enlazaremos con nuestro programa y las librerías de tercero que usemos.

\lstinputlisting[language=make, firstline=65, lastline=73, breaklines=true]{codigo_fuente/Makefile_principal}
Estas son las reglas que utilizamos para generar los ficheros con extensión `.o' a partir de su correspondiente archivo de código fuente.

\lstinputlisting[language=make, firstline=76, lastline=89, breaklines=true]{codigo_fuente/Makefile_principal}
Estas reglas las utilizaremos en el caso de querer generar archivos que hayan sido solo preprocesados o preprocesados y compilados sin ser ensamblados. Para usarlas habrá que indicar explícitamente que archivo queremos generar, por ejemplo \comando{make src/sketch.s} para obtener el archivo en ensamblador a partir de nuestro código C++ de `sketch.cpp'.

\lstinputlisting[language=make, firstline=91, lastline=93, breaklines=true]{codigo_fuente/Makefile_principal}
Con este objetivo realizamos el enlazado de los archivos compilados para generear el ejecutable. En las dependencias se encuentran todos los archivos y reglas necesarias para llevar acabo el enlazado.

\lstinputlisting[language=make, firstline=95, lastline=98, breaklines=true]{codigo_fuente/Makefile_principal}
Este objetivo tiene la finalidad de enlazar el programa usando un script de enlazado diferente, que no inserta un bootloader. De esta forma podremos crear un ejecutable que puede ser usado en \programa{MPLAB X} para depuración.

\lstinputlisting[language=make, firstline=100, lastline=103, breaklines=true]{codigo_fuente/Makefile_principal}
De la misma forma que lo hace \programa{MPIDE} creamos el archivo con extensión `.hex', que cargaremos mas tarde en el microcontrolador. Este objetivo depende del objetivo \comando{link}, ya que necesitamos el programa enlazado.

\lstinputlisting[language=make, firstline=105, lastline=106, breaklines=true]{codigo_fuente/Makefile_principal}
Este es el objetivo que hemos definido antes como el objetivo por defecto. Es el que se encarga de invocar a \programa{avrdude} que cargará nuestro programa en la placa.

\lstinputlisting[language=make, firstline=108, lastline=113, breaklines=true]{codigo_fuente/Makefile_principal}
Por último, el objetivo \comando{clean} nos permitirá eliminar todos los archivos creados durante el proceso de compilación, enlazado y carga.

\section{Niveles de optimización}
Durante la compilación es posible especificar, mediante la opción \comando{-O} diferentes niveles de optimización. Estos niveles agrupan una serie de optimizaciones.

\begin{table}[H]
\begin{center}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    Nivel de optimización & Descripción\\
    \hline
    \hline
   	\comando{-O0} & Opción por defecto. Reduce el tiempo de compilación y facilita la depuración.\\
    \hline
    \comando{-O1} & Optimiza, pero aumenta el tiempo de compilación y la memoria empleada.\\
    \hline
    \comando{-O2} & Optimiza más todavía. \programa{GCC} realiza casi todas la optimizaciones que no impliquen aumento de la velocidad a costa de un mayor tamaño del programa.\\
    \hline
    \comando{-O3} & Optimiza todavía más que \comando{-O2}, incluyendo las optimizaciones que aumenten el tamaño del ejecutable.\\
    \hline
    \comando{-Os} & Optimiza el tamaño del programa. Habilita todas las optimizaciones de \comando{-O2} que normalmente no aumenten el tamaño del código y realiza más optimizaciones destinadas a reducir el tamaño del programa.\\
    \hline
  \end{tabularx}
\end{center}
\caption{Niveles de optimización}
\label{tab:optimizacionx}
\end{table}

Cada uno de estos niveles (a excepción de \comando{-Os}) añade una serie de optimizaciones sobre el nivel inicial \comando{-O0}.\\
Veamos que optimizaciones lleva a cabo cada nivel. Esto podemos verlo usando el comando ``\comando{pic32-gcc -Ox -Q --help=optimizers | grep enabled}''.\\
\newline
Optimizaciones del nivel 0:
\begin{multicols}{2}
\begin{itemize}[noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt]
	\item -falign-loops
	\item -fargumnt-alias
	\item -fbranch-count-reg
	\item -fcommon
	\item -fdata-sections
	\item -fdce
	\item -fdelete-null-pointer-checks
	\item -fdse
	\item -fearly-inlining
	\item -fgcse-lm
	\item -finline-functions-called-once
	\item -fivopts
	\item -fjump-tables
	\item -fmath-errno
	\item -fmove-loop-invariants
	\item -fpeephole
	\item -frename-registers
	\item -fsched-critical-path-heuristic
	\item -fsched-dep-count-heuristic
	\item -fsched-group-heurisitc
	\item -fsched-interblock
	\item -fsched-last-insn-heuristic
	\item -fsched-spec
	\item -fsched-spec-insn-heuristic
	\item -fsched-stalled-insns-dep
	\item -fsigned-zeros
	\item -fsplit-ivs-in-unroller
	\item -ftoplevel-reorder
	\item -ftrapping-math
	\item -ftree-cselim
	\item -ftree-forwprop
	\item -ftree-loop-im
	\item -ftree-loop-ivcanon
	\item -ftree-loop-optimize
	\item -ftree-phiprop
	\item -ftree-pta
	\item -ftree-reassoc
	\item -ftree-scev-cprop
	\item -ftree-slp-vectorize
	\item -ftree-vect-loop-version
	\item -funit-at-a-time
	\item -fvar-tracking
	\item -fvar-tracking-assignments
	\item -fweb
\end{itemize}
\end{multicols}

Optimizaciones que añade el nivel `O1' al nivel `O0':

\begin{multicols}{2}
\begin{itemize}[noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt]
	\item -fcprop-registers
	\item -fdefer-pop
	\item -fdelayed-branch
	\item -fforward-propagate
	\item -fguess-branch-probability
	\item -fif-conversion
	\item -fif-conversion2
	\item -fipa-pure-const
	\item -fipa-reference
	\item -fmerge-constants
	\item -fomit-frame-pointer
	\item -fsplit-wide-types
	\item -ftree-ccp
	\item -ftree-ch
	\item -ftree-copy-prop
	\item -ftree-copyrename
	\item -ftree-dce
	\item -ftree-dominator-opts
	\item -ftree-dse
	\item -ftree-fre
	\item -ftree-sink
	\item -ftree-sra
	\item -ftree-ter
\end{itemize}
\end{multicols}

Optimizaciones que añade el nivel `O2' al nivel `O1':

\begin{multicols}{2}
\begin{itemize}[noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt]
	\item -falign-functions
	\item -falign-jumps
	\item -falign-labels
	\item -fcaller-saves
	\item -fcrossjumping
	\item -fcse-follow-jumps
	\item -fexpensive-optimizations
	\item -fgcse
	\item -finline-small-functions
	\item -fipa-cp
	\item -fipa-sra
	\item -foptimize-register-move
	\item -foptimize-sibling-calls
	\item -fpeephole2
	\item -fregmove
	\item -fremove-local-statics
	\item -freorder-blocks
	\item -freorder-functions
	\item -frerun-cse-after-loop
	\item -fschedule-insns
	\item -fschedule-insns2
	\item -fstrict-aliasing
	\item -fthread-jumps
	\item -ftree-builtin-call-dce
	\item -ftree-pre
	\item -ftree-switch-conversion
	\item -ftree-vrp
\end{itemize}
\end{multicols}

Optimizaciones que añade el nivel `O3' al nivel `O2':

\begin{multicols}{2}
\begin{itemize}[noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt]
	\item -fgcse-after-reload
	\item -finline-functions
	\item -fipa-cp-clone
	\item -fpredictive-commoning
	\item -ftree-pre-partial-partial
	\item -ftree-vectorize
	\item -funswitch-loops
\end{itemize}
\end{multicols}

El nivel `Os' realiza las mismas optimizaciones que `O2' menos las siguientes:
\begin{multicols}{2}
\begin{itemize}[noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt]
	\item -falign-functions
	\item -falign-jumps
	\item -falign-loops
	\item -falign-labels
	\item -freorder-blocks
	\item -freorder-blocks-and-partition
	\item -fprefetch-loop-arrays
	\item -ftree-vect-loop-version
\end{itemize}
\end{multicols}

Las optimizaciones que comienzan con `fsched' se usan para reordenar las instrucciones. También hay varias optimizaciones que afectan a objetos `tree' que, de acuerdo a la documentación de GCC\footnote{http://gcc.gnu.org/onlinedocs/gccint/Tree-overview.html} son estructuras centrales de datos usadas para la representación interna. Un `tree' es un tipo de puntero que puede apuntar a dataos de diferente tipo.\\
Las optimizaciones `finline-functions-called-once', `finline-functions' y `finline-small-functions' sustituyen la llamada a la función por el código de la misma. La primera de ellas está habilitada en todos los niveles de optimización y sustituye, como su nombre indica, todas las funciones que sean llamadas una sola vez. `finline-small-functions' realiza la sustitución solo si su tamaño es menor quelas instrucciones necesarias para llamar a la función, en ensamblador. Estas dos optimizaciones hacen posible escribir pequeñas funciones auxiliares que puedan facilitar tanto la escritura como la lectura de nuestro programa sin suponer una disminución del rendimiento. La última de estas optimizaciones, `finline-functions', considera todas las funciones para sustituir su llamada por el código.\\
En el caso de las optimizaciones que comienzan por `falign' \programa{gcc} se encarga de alinear los elementos especificados en cada una de estas optimizaciones para reducir los accesos a memoria a cambio de ocupar más espacio. Es por esto que en el nivel `Os' se desactivan estas, entre otras.

\newpage
\section{Aplicación para ChipKIT}

En esta sección vamos a ver el programa que emplearemos para observar y analizar los diferentes niveles de optimización que lleva acabo \comando{gcc}. Se trata de un terminal remoto al que nos conectamos a través del puerto 23 con el protocolo TCP. Una vez conectados disponemos de varios comandos para ordenar un array que pasaremos como parámetro. Los comandos disponibles son los siguientes:

\begin{description}
	\item[\comando{bubble0}, \comando{bubble1}, \comando{bubble2}, \comando{bubble3}] Ordenan los números usando el algoritmo `Bubble Sort'.
	\item[\comando{quick0}, \comando{quick1}, \comando{quick2}, \comando{quick3}] Ordenan los números usando el algoritmo `Quick Sort'.
	\item[\comando{sel0}, \comando{sel1}, \comando{sel2}, \comando{sel3}] Ordenan los números usando el algoritmo `Selection Sort'.
	\item[\comando{comparar}] Reordena un array de números aleatorios usando todos los algoritmos anteriores.
	\item[\comando{help}] Muestra los comandos disponibles.
	\item[\comando{exit}] Cierra la conexión.
\end{description}

El número que acompaña a cada uno de los comandos es el nivel de optimización con el que han sido compilados. El resultado que devuelve cada una de las órdenes es la lista ordenada y el tiempo de ejecución, esto último se muestra también en la pantalla OLED del chipKIT IO Shield.\\
Para la realización del programa se ha usado como base el ejemplo del servidor Telnet que viene incluido con la biblioteca `chipKITEthernet'. Veamos la estructura y funcionamiento de nuestro `sketch'\footnote{Archivo donde definimos las funciones \comando{setup()} y \comando{loop()}}.\\
\lstinputlisting[firstline=1, lastline=3, breaklines=true]{codigo_fuente/sketch.cpp}
Comenzamos incluyendo la biblioteca del Shield Ethernet, IO Shield y el archivo de cabecera \programa{funciones.h} que contiene la declaración de los diferentes algoritmos de ordenación que usaremos en los comandos expuestos anteriormente.\\

\lstinputlisting[firstline=5, lastline=6]{codigo_fuente/sketch.cpp}
Definimos el tamaño máximo del mensaje, esto es, la máxima longitud de la línea que el cliente puede envíar a nuestro programa, esto incluye el comando seguido por el array. También definimos el tamaño máximo del array que acepta el programa, siendo este la mitad que el mensaje. Esta longitud debería ser suficiente ya que, con números de un solo dígito (o carácter en este caso), no es posible superar este tamaño ya que por cada uno de estos numeros deberemos añadir un separador\footnote{El caracter que separe los números puede ser tanto un espacio una coma o tabulador.}, lo que implica un mínimo de dos caracteres por dígito, sin contar el comando.

\lstinputlisting[firstline=8, lastline=11]{codigo_fuente/sketch.cpp}
Estos son los arrays que usaremos para guardar el mensaje recibido del cliente, el comando extraído de ese mensaje, el array de números que pueda haber en el mensaje y si es o no el primer mensaje que recibimos del cliente.\footnote{El protocolo telnet suele enviar ciertos caracteres al iniciar una conexión que descartamos.}

\lstinputlisting[firstline=15, lastline=34]{codigo_fuente/sketch.cpp}
Creamos la estructura algoritmo con la que podremos asociar cómodamente el nombre en forma de cadena de caracteres de la función con su nombre. Justo después declaramos un array de estructuras algoritmo que contiene esta información. Se usará a la hora de mostrar los resultados de los algoritmos de ordenación.

\lstinputlisting[firstline=37, lastline=38]{codigo_fuente/sketch.cpp}
Esta parte está inalterada con respecto al ejemplo que viene con la biblioteca Ethernet. Aquí declaramos la dirección física que queramos que tenga nuestro dispositivo. Si la inicializamos a 0 la dirección física que se usará será la del propio dispositivo. En el caso de elegir un valor diferente será este el que se use\footnote{En algunas aplicaciones puede ser interesante modificar este valor para enmascarar la identidad del dispositivo o para suplantar la de otro, pero esto se sale del objetivo de este proyecto.}.

\lstinputlisting[firstline=41, lastline=42]{codigo_fuente/sketch.cpp}
Ahora declaramos la dirección de red (IP) de nuestro dispositivo\footnote{Se ha elegido esta en concreto (10.0.0.8) porque durante el desarrollo del programa el dispositivo se encontraba conectado a la red 10.0.0.0/24}. Es posible no declarar la dirección IP del dispositivo para usar DHCP.

\lstinputlisting[firstline=52, lastline=55]{codigo_fuente/sketch.cpp}
Creamos una instancia de la clase Server, con nombre \comando{server} en el puerto 23. Es posible elegir otros puertos, pero se ha elegido este por ser el que usa el servicio de terminal remoto Telnet.

\lstinputlisting[firstline=57, lastline=61]{codigo_fuente/sketch.cpp}
Declaramos funciones auxiliares que se utilizarán a lo largo del programa:
\begin{description}
	\item[\comando{print\_array}] es una función que imprime un array tanto por el puerto serie como al cliente.
	\item[\comando{selecciona\_comando}] se encarga de llamar a la función \comando{ejecuta\_comando} pasándole como parámetro el númor de comando adecuado, el array a ordenar y la longitud de dicho array.
	\item[\comando{array\_aleatorio}] genera un array de números aleatorio de longitud \comando{MAX\_LONG\_ARRAY}.
	\item[\comando{ejecuta\_comando}] ejecuta el comando cuyo índice le pasemos como parámetro.
	\item[\comando{compara}] llama a \comando{ejecuta\_comando} para cada función de ordenación que tengamos, pasándole como parámetro el mismo array de números aleatorios a todas.
\end{description}

\lstinputlisting[firstline=63, lastline=77]{codigo_fuente/sketch.cpp}
Función \comando{setup()} en la que inicializamos el shield ethernet con la función \comando{Ethernet.begin(mac, ip)}\footnote{Si quisiéramos usar DHCP en lugar de una IP fija podemos llamar a la función \comando{Ethernet.begin(mac)}.}, inicializamos el servidor para que comience a escuchar a la espera de nuevos clientes e inicializamos el puerto serie. Este último se usa principalmente para facilitar la depuración del programa, puesto que el acceso será via Telnet no por el puerto serie. Además inicializaremos la pantalla oled del IO Shield y mostraremos en ella el nombre del programa.

\lstinputlisting[firstline=73, lastline=76]{codigo_fuente/sketch.cpp}
Si se conecta un cliente, nos aseguramos de que el contenido del mensaje, el comando y el array de números es nulo.

\lstinputlisting[firstline=78, lastline=101, breaklines=true]{codigo_fuente/sketch.cpp}
El método \comando{client.available()} devuelve la cantidad de bytes que hay disponible en el buffer de recepción mientras que \comando{client.read()} nos permite leerlos uno a uno (cada vez que llamamos a este método sin argumentos lee el siguiente byte hasta terminar el buffer). Cuando ya hemos leído todo el buffer, que debido a su implementación está limitado a 1000 bytes, \comando{client.read()} devolverá \comando{-1}. Cuando esto ocurre nos aseguramos de no guardar este valor y mientras siga devolviendo esto, lo ignoramos. Cada vez que leemos un byte aumentamos la variable \comando{m} asegurándonos de no superar el tamaño máximo de mensaje. Seguimos leyendo hasta que recibamos el carácter \comando{\textbackslash n} (retorno de carro) que guardaremos en el mensaje y dejaremos de leer del buffer de recepción. Cuando hemos terminado de leer guardamos el valor de la variable \comando{m}, como tamaño del mensaje en la variable \comando{message\_size}.

\lstinputlisting[firstline=102, lastline=145, breaklines=true, resetmargins=true]{codigo_fuente/sketch.cpp}

Una vez tenemos guardado el mensaje en el array \comando{message}, procedemos dividirlo en el comando y el array de números que ordenaremos más tarde. Para realizar la división buscamos en el array los separadores, esto lo hacemos en el primer \comando{if} que hay nada más comenzar una iteración. En este caso los separadores pueden ser espacios, comas, tabuladores y retorno de carro\footnote{Están incluídos tanto \textbackslash r como \textbackslash n para que funcione con cualquier tipo de retorno de carro, ya sea CR o LF. De está forma podemos conectarnos mediante telnet, que finaliza las líneas con \textbackslash r\textbackslash n o directamente mediante TCP usando, por ejemplo \programa{netcat} o una función dentro de algún programa.}. Utilizamos la variable \comando{cantidad\_num} para identificar el comando y para conocer la cantidad de números que hay en el mensaje. Cada vez que encontremos uno de los separadores esta variable se incrementa. La primera vez que encontramos un separador y, por lo tanto, la variable \comando{cantidad\_num} es nula, sabemos que se trata del comando, ya que este debe ser el primer elemento del mensaje. En este momento, copiamos el contenido del mensaje hasta el índice actual a la variable comando (comprobando antes la longitud del array a copiar para evitar desbordamientos) y obtenemos el número de comando mediante la función \comando{deco\_comando}, que trataremos más adelante.\\
A partir de aquí, todo lo que debe preceder al comando deben ser números. Antes de convertir los números a enteros, los extraemos, guardándolos en un array temporal llamado \comando{numero}. Para hacer esto usamos un nuevo índice (\comando{j}) que indicará la posición dentro del array \comando{numero}. Este índice se reinicia cada vez que encontramos un separador, mientras que aumenta en cada iteración cuando no lo encotremos. De está forma podemos copiar los números contenidos entre dos separadores al array \comando{numero}. Cada vez que encontremos un separador intaremos convertir \comando{numero} a un entero que guardaremos en el array de enteros \comando{number\_array}. En el caso de no ser válido, detendremos el bucle, invalidamos el array de numeros e indicamos por el puerto serie que ha habido un error al convertir.\\
En el caso de que el mensaje fuera correcto, al terminar este bucle tendremos el array \comando{number\_array} que contiene todos los números,la variable \comando{cantidad\_num} que indica la cantidad de números en dicho array\footnote{Esta variable es necesaria puesto que generalmente no se llenará el array al completo.} y el número de comando en \comando{num\_comando}. 

\lstinputlisting[firstline=147, lastline=164, breaklines=true]{codigo_fuente/sketch.cpp}
Comprobamos que hemos recibido algún número y guardamos la cantidad de números en \comando{num\_array} en la variable \comando{size}. Imprimimos el tamaño del array y el comando por el puerto serie para depuración. Borramos lo que pueda haber en el buffer de recepción con \comando{client.flush\(\);}. Por último llamamos a la función ejecuta\_comando, a la que le pasamos una referencia al cliente, el número del comando y la cantidad de números que componen \comando{num\_array}\footnote{No le pasamos \comando{num\_array} ya que es una variable global.}. Cuando ha acabado envíamos al cliente e imprimimos por el puerto serie el resultado de la ejecución del comando, que debería ser (en caso de ejecutar alguno de los comandos de ordenación) \comando{num\_array} ordenado.
\newline
Veamos el resto de funciones que podemos encontrar en el archivo `sketch.cpp' y que hemos utilizado en la función \comando{loop()}.\\

\lstinputlisting[firstline=166, lastline=177, breaklines=true]{codigo_fuente/sketch.cpp}
Está función tiene como único objetivo envíar al cliente y por puerto serie el array que pasemos como parametro, para poder visualizarlo.

\lstinputlisting[firstline=179, lastline=187, breaklines=true]{codigo_fuente/sketch.cpp}
Nuestras funciones de ordenación, modifican el array que se les pasa como parámetro (el array es pasado por referencia), por lo que está función copia el array \comando{number\_array} a \comando{resultado} y será este último el que modifiquemos. Esto lo hacemos por si fuera necesario disponer del array original para comparar u otras funciones.

\lstinputlisting[firstline=189, lastline=236, breaklines=true]{codigo_fuente/sketch.cpp}
Está función compara la cadena de caracteres \comando{comando} con los diferentes comandos disponibles y devuelve el código del comando al que corresponda. Si no corresponde a ningún comando devolvemos el comando especial \comando{NOP}.

\lstinputlisting[firstline=238, breaklines=true]{codigo_fuente/sketch.cpp}
Por último, esta función ejecuta las subrutinas asociadas al comando que le pasamos como parámetro. Vemos que cuando la función que se ejecuta es alguno de los algoritmos de ordenación medimos su duración usando tanto la función \comando{micros()} como la función \comando{millis()}, que devuelven el tiempo en microsegundos y milisegundos respectivamente. Esto es necesario ya que si el array es muy pequeño, \comando{millis()} no dispondrá de la precisión necesaria para realizar una medida adecuada, mientras que si el array es muy grande es posible que el contador del que hace uso \comando{micros()} desborde y obtengamos una medida inválida. Una vez ejecutado el algoritmo de ordenación envíamos al cliente el tiempo que ha tardado en ejecutarse. Además, disponemos del comando \comando{HELP} que indica al cliente los comandos que tiene a su disposición, además del comando \comando{EXIT} que termina la conexión con el cliente. Si el comando no corresponde a ninguno de los anteriores, es decir, se trata del comando \comando{NOP} se le indicará al cliente que el comando es inválido.
